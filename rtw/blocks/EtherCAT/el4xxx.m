function rv = el4xxx(model,input_type, scale)

entries = [...
           hex2dec('7000'), 17, 16, 2016; ...
           hex2dec('7010'), 17, 16, 2016; ...
           hex2dec('7020'), 17, 16, 2016; ...
           hex2dec('7030'), 17, 16, 2016; ...
           hex2dec('7040'), 17, 16, 2016; ...
           hex2dec('7050'), 17, 16, 2016; ...
           hex2dec('7060'), 17, 16, 2016; ...
           hex2dec('7070'), 17, 16, 2016; ...
            
           hex2dec('6411'),  1, 16, 2016; ... 
           hex2dec('6411'),  2, 16, 2016; ... 

           hex2dec('7000'),  1, 16, 2016; ...
           hex2dec('7010'),  1, 16, 2016; ...
           hex2dec('7020'),  1, 16, 2016; ...
           hex2dec('7030'),  1, 16, 2016; ...
           ];
        

pdo = [...
         hex2dec('1600'),  1,  1;...      %RxPdo 004,
         hex2dec('1601'),  2,  2;...
         hex2dec('1602'),  3,  3;...
         hex2dec('1603'),  4,  4;...
         hex2dec('1604'),  5,  5;...
         hex2dec('1605'),  6,  6;...         
         hex2dec('1606'),  7,  7;...
         hex2dec('1607'),  8,  8;...

         hex2dec('1600'),  9,  9;...         
         hex2dec('1601'), 10, 10;...         

         hex2dec('1600'), 11, 11;...
         hex2dec('1601'), 12, 12;...
         hex2dec('1602'), 13, 13;...
         hex2dec('1603'), 14, 14;...
      ];



%   Model                  ProductCode          Revision       TxStart|TxEnd

models = struct(...
    'EL4004'          ,[hex2dec('0fa43052'), hex2dec('00100000'),  1,   4 ], ...
    'EL4008'          ,[hex2dec('0fa83052'), hex2dec('00100000'),  1,   8 ], ...
    'EL4028'          ,[hex2dec('0fbc3052'), hex2dec('00100000'),  1,   8 ],  ...
    'EL4034'          ,[hex2dec('0fc23052'), hex2dec('00100000'),  1,   4 ], ...
    'EL4102'          ,[hex2dec('10063052'), hex2dec('F0000000'),  0, 0 ]  , ...
    'EL4102v2'        ,[hex2dec('10063052'), 0                  ,  9,  10 ], ...
    'EL4112'          ,[hex2dec('10103052'), 0                  ,  9,  10 ], ...  
    'EL4122'          ,[hex2dec('101a3052'), 0                  ,  9,  10 ], ...  
    'EL4132'          ,[hex2dec('10243052'), hex2dec('F0000000'),  0, 0 ]  , ...
    'EL4132v2'        ,[hex2dec('10243052'), 0                  ,  9,  10 ], ...
    'EL4134r03F80000' ,[hex2dec('10263052'), hex2dec('03F80000'), 11,  14 ], ...
    'EL4134r03F90000' ,[hex2dec('10263052'), hex2dec('03F90000'),  1,   4 ]  ...
    );


input_unit = struct(...
    'EL4004'          , '0..10 V' , ...
    'EL4008'          , '0..10 V' , ...
    'EL4028'          , '4..20 mA', ...
    'EL4034'          , '+-10 V', ...
    'EL4102'          , '0..10V', ...
    'EL4102v2'        , '0..10V', ...
    'EL4112'          , '0..20mA', ...  
    'EL4122'          , '4..20mA', ...  
    'EL4132'          , '+-10V', ...
    'EL4132v2'        , '+-10V', ...
    'EL4134r03F80000' , '+-10V', ...
    'EL4134r03F90000' , '+-10V'...
    );

rv.input_unit = input_unit.(model);

rv.SlaveConfig.vendor = 2;
rv.SlaveConfig.description = model;


product = models.(model);
rv.SlaveConfig.product = product(1);

% RxPdo SyncManager
rv.SlaveConfig.sm = { {2 0 {}} };

% Populate the RxPDO Inputs structure
rv.SlaveConfig.sm{1}{3} = arrayfun(...
        @(x) {pdo(x,1), entries(pdo(x,2):pdo(x,3),:)}, ...
        product(3):product(4), ...
        'UniformOutput',0 ...
);

% set scale for double inputs
scale_int = 2^15;

% Set scale and for each data type
rv.PortConfig.input.full_scale = scale_int;

%(isempty(scale) || numel(scale)==1 || numel(scale) == number_elements)
%if     strcmp(input_type,'Separate Inputs') &&...
%         (isempty(scale) || numel(scale)==1 || numel(scale) == number_elements)
%           if numel(scale) == 1
%               rv.PortConfig.input.scale = ...
%                 {'Scale', [ones(1,number_elements)]*scale};
%           else
%               rv.PortConfig.input.scale = {'Scale', scale};
%           end
%elseif strcmp(input_type,'Vector Input') &&...
%          (isempty(scale) || numel(scale)==1)
%           rv.PortConfig.input.scale = {'Scale', scale};
%else
%        warning('EtherLAB:Beckhoff:EL4xxx:scale', ['The dimension of the'...
%       ' scale input does not match to the number of elements of the'...
%       ' terminal. Please choose a valid input, or the scale is being ignored'])
%end

r = 0 : product(4) - product(3);
if strcmp(input_type, 'Vector Input')
    rv.PortConfig.input.pdo = [zeros(numel(r),4)];
    rv.PortConfig.input.pdo(:,2) = r;
else
    rv.PortConfig.input = arrayfun(@(x) struct('pdo', [0, x, 0, 0]), r);
end


number_elements = (product(4)-product(3)+1);

if (isempty(scale) || numel(scale)==1 || numel(scale) == number_elements)   
    if strcmp(input_type,'Separate Inputs')        
        for k = 1:number_elements
            if numel(scale) == 1
                rv.PortConfig.input(k).gain = {'Gain', scale};
            elseif numel(scale) == number_elements 
                rv.PortConfig.input(k).gain = {'Gain', scale(k)};
            else
                rv.PortConfig.input(k).gain = {'Gain', []};
            end
         end
    else
        rv.PortConfig.input.gain = {'Gain', scale};
    end
     % if input is wrong, fill with emptys
else 
    if strcmp(input_type,'Separate Inputs')
        for k = 1:number_elements
            rv.PortConfig.input(k).gain = [];
        end
    else
        rv.PortConfig.input.gain = {'Gain', scale};
    end
    warning('EtherLAB:Beckhoff:EL31xx:scale', ['The dimension of the'...
    ' scale input does not match to the number of elements of the'...
    ' terminal. Please choose a valid input, or the scale is being ignored'])
end

