/******************************************************************************
 *
 * $Id$
 *
 * The code generated by Real-Time Workshop (TM) will not compile in
 * kernel's kbuild environment due to extensive use of standard ANSI-C, as 
 * well as floating point functions. However, the kernel will only load 
 * modules that were built using kbuild.
 *
 * To circumnavigate this dilemma, the same procedure is used that is applied
 * when adding binary code to a kernel module: the _shipped method.
 *
 * To this end all RTW code and its libraries are compiled in user space 
 * inside the normal ANSI-C environment, using the same CFLAGS
 * that are used during kbuild. The interface between kernel code and RTW
 * code is implemented in this file.
 * 
 * Copyright (C) 2008  Richard Hacker
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Original copyright notice:
 *           Autor: Richard Hacker
 *
 *           (C) Copyright IgH 2005
 *           Ingenieurgemeinschaft IgH
 *           Heinz-Baecker Str. 34
 *           D-45356 Essen
 *           Tel.: +49 201/36014-0
 *           Fax.: +49 201/36014-14
 *           E-mail: info@igh-essen.com
 *
 *****************************************************************************/ 

#include <rt_app.h>
#include <fio_ioctl.h>

#include <rtw_time.h>
#include <rtw_defines.h>
#include <rtw_data_interface.h>

#include "rtmodel.h"
#include "rt_sim.h"


#ifndef RT
# error "must define RT"
#endif

#ifndef MODEL
# error "must define MODEL"
#endif

#ifndef NUMST
# error "must define number of sample times, NUMST"
#endif

#ifndef NCSTATES
# error "must define NCSTATES"
#endif

/*====================*
 * External functions *
 *====================*/
extern RT_MODEL *MODEL(void);

extern void MdlInitializeSizes(void);
extern void MdlInitializeSampleTimes(void);
extern void MdlStart(void);
extern void MdlOutputs(int_T tid);
extern void MdlUpdate(int_T tid);
extern void MdlTerminate(void);

#ifdef MULTITASKING
extern const char* rt_OneStepMain(void);
extern const char* rt_OneStepTid(uint_T);
#else
extern const char* rt_OneStep(void);
#endif
extern void mdl_set_error_msg(const char *msg);

double etl_world_time[NUMST];

#if NCSTATES > 0
  extern void rt_ODECreateIntegrationData(RTWSolverInfo *si);
  extern void rt_ODEUpdateContinuousStates(RTWSolverInfo *si);

# define rt_CreateIntegrationData(S) \
    rt_ODECreateIntegrationData(rtmGetRTWSolverInfo(S));
# define rt_UpdateContinuousStates(S) \
    rt_ODEUpdateContinuousStates(rtmGetRTWSolverInfo(S));
# else
# define rt_CreateIntegrationData(S)  \
      rtsiSetSolverName(rtmGetRTWSolverInfo(S),"FixedStepDiscrete");
# define rt_UpdateContinuousStates(S) \
      rtmSetT(S, rtsiGetSolverStopTime(rtmGetRTWSolverInfo(S)));
#endif


#if !defined(MULTITASKING)  /* SINGLETASKING */

/* Function: rtOneStep ========================================================
 *
 * Abstract:
 *      Perform one step of the model. This function is modeled such that
 *      it could be called from an interrupt service routine (ISR) with minor
 *      modifications.
 */
const char *
rt_OneStep()
{
    RT_MODEL *S = rt_app.app_privdata;
    real_T tnext;
    double *wt;

    etl_world_time[0] = (double)task_stats[0].time.tv_sec 
        + (double)task_stats[0].time.tv_usec / 1.0e6;
    for (wt = etl_world_time; wt < etl_world_time + NUMST; wt++) {
        *wt = etl_world_time[0];
    }

    tnext = rt_SimGetNextSampleHit();
    rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S),tnext);

    MdlOutputs(0);

    MdlUpdate(0);
    rt_SimUpdateDiscreteTaskSampleHits(rtmGetNumSampleTimes(S),
                                       rtmGetTimingData(S),
                                       rtmGetSampleHitPtr(S),
                                       rtmGetTPtr(S));

    if (rtmGetSampleTime(S,0) == CONTINUOUS_SAMPLE_TIME) {
        rt_UpdateContinuousStates(S);
    }

    return rtmGetErrorStatusFlag(S);
} /* end rtOneStep */

#else /* MULTITASKING */

# if TID01EQ == 1
#  define FIRST_TID 1
# else
#  define FIRST_TID 0
# endif

/* Function: rtOneStep ========================================================
 *
 * Abstract:
 *      Perform one step of the model. This function is modeled such that
 *      it could be called from an interrupt service routine (ISR) with minor
 *      modifications.
 *
 *      This routine is modeled for use in a multitasking environment and
 *	therefore needs to be fully re-entrant when it is called from an
 *	interrupt service routine.
 *
 * Note:
 *      Error checking is provided which will only be used if this routine
 *      is attached to an interrupt.
 *
 */
const char *
rt_OneStepMain()
{
    RT_MODEL *S = rt_app.app_privdata;
    real_T tnext;

    etl_world_time[FIRST_TID] = (double)task_stats[0].time.tv_sec 
        + (double)task_stats[0].time.tv_usec / 1.0e6;
    etl_world_time[0] = etl_world_time[FIRST_TID];


    /*******************************************
     * Step the model for the base sample time *
     *******************************************/

    tnext = rt_SimUpdateDiscreteEvents(
                rtmGetNumSampleTimes(S),
                rtmGetTimingData(S),
                rtmGetSampleHitPtr(S),
                rtmGetPerTaskSampleHitsPtr(S));

    rtsiSetSolverStopTime(rtmGetRTWSolverInfo(S),tnext);

    MdlOutputs(FIRST_TID);

    MdlUpdate(FIRST_TID);

    if (rtmGetSampleTime(S,0) == CONTINUOUS_SAMPLE_TIME) {
        rt_UpdateContinuousStates(S);
    } else {
        rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), 
                                     rtmGetTimingData(S), 0);
    }

#if FIRST_TID == 1
    rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), 
                                 rtmGetTimingData(S),1);
#endif

    return rtmGetErrorStatusFlag(S);
} /* end rtOneStepMain */

const char *
rt_OneStepTid(uint_T tid)
{
    RT_MODEL *S = rt_app.app_privdata;
    uint_T rtw_tid = tid + FIRST_TID;

    etl_world_time[rtw_tid] = (double)task_stats[tid].time.tv_sec 
        + (double)task_stats[tid].time.tv_usec / 1.0e6;

/*
    if (rtmGetSampleHitArray(S)[rtw_tid]) {
        rtmSetErrorStatusFlag(S, "Sample hit was not ready");
    }
*/


    MdlOutputs(rtw_tid);

    MdlUpdate(rtw_tid);

    rt_SimUpdateDiscreteTaskTime(rtmGetTPtr(S), 
                                 rtmGetTimingData(S),rtw_tid);

    return rtmGetErrorStatusFlag(S);

} /* end rtOneStepTid */

#endif /* MULTITASKING */

void
mdl_set_error_msg(const char *msg)
{
    RT_MODEL *S = rt_app.app_privdata;

    rtmSetErrorStatusFlag(S, msg);
}

/* Function: app_stop ========================================================
 *
 * Abstact:
 *      Cleanup model to free memory
 */
void 
app_stop(void)
{
    MdlTerminate();
}

/* Function: main ============================================================
 *
 * Abstract:
 *      Execute model on a generic target such as a workstation.
 */
const char *
app_start(void)
{
    RT_MODEL  *S = MODEL();
    const char *errmsg;
    int i;

    /************************
     * Initialize the model *
     ************************/
    if ((errmsg = app_info_init(S))) {
        return errmsg;
    }

    if (rtmGetErrorStatus(S) != NULL) {
	    return rtmGetErrorStatus(S);
    }

    MdlInitializeSizes();
    MdlInitializeSampleTimes();
    
    if ((errmsg = rt_SimInitTimingEngine(
                    rtmGetNumSampleTimes(S),
                    rtmGetStepSize(S),
                    rtmGetSampleTimePtr(S),
                    rtmGetOffsetTimePtr(S),
                    rtmGetSampleHitPtr(S),
                    rtmGetSampleTimeTaskIDPtr(S),
                    rtmGetTStart(S),
                    &rtmGetSimTimeStep(S),
                    &rtmGetTimingData(S)))) {
        return errmsg;
    }
    rt_CreateIntegrationData(S);

    MdlStart();
    if ((errmsg = rtmGetErrorStatus(S))) {
        MdlTerminate();
        return errmsg;
    }

    /* Register model callbacks */
#ifdef MULTITASKING
    rt_app.rt_OneStepMain = rt_OneStepMain;
    rt_app.rt_OneStepTid = rt_OneStepTid;
#else
    rt_app.rt_OneStepMain = rt_OneStep;
    rt_app.rt_OneStepTid = NULL;
#endif
    rt_app.set_error_msg = mdl_set_error_msg;

    for (i = 0; i < rt_app.num_st; i++) {
        task_period[i] = (unsigned int)
            (rtmGetSampleTime(S, i + (TID01EQ ? 1 : 0))*1.0e6 + 0.5);
    }

    // Cannot assign this in struct definition :(
//    rt_app.symbol_len = model_symbols_len;

    return NULL;

} /* end main */
