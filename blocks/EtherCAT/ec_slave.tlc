%implements "ec_slave" "C"

%%
%% Hardware Driver for Beckhoff's EtherCAT Analog Input Terminal
%% series EL31xx
%% 
%% This TLC Implements the necessary IO Functions to communicate
%% with the EtherCAT Driver enabling the usage of a analog input
%% terminal.
%%
%% Copyright (C) 2006
%% Richard Hacker
%% IgH Essen GmbH
%% 
%% License: GPL

%include "EtherCAT.tlc"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockTypeSetup( block, system ) void
%% This function checks whether the EtherCAT system has been called once
%% before already, which is demonstrated by the existance of variable 
%% ::EtherCAT. If not, include C-header file for EtherCAT, 
%% and declare a variable where the slave's data structure is placed 
%% by EtherCAT when registering the slaves during mdlStart()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %<InitEtherCAT()>
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockInstanceSetup( block, system ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if EXISTS(InputPortSpec)
    %assign nm = SIZE(InputPortSpec)
    %if nm[1] > 0 && nm[1] != 4
      %error Unexpected column count for InputPortSpec %<InputPortSpec>
    %endif
    %addtorecord block NumInputs nm[0]
  %else
    %addtorecord block NumInputs 0
  %endif

  %if EXISTS(OutputPortSpec)
    %assign nm = SIZE(OutputPortSpec)
    %if nm[1] > 0 && nm[1] != 6
      %error Unexpected column count for OutputPortSpec %<OutputPortSpec>
    %endif
    %addtorecord block NumOutputs nm[0]
  %else
    %addtorecord block NumOutputs 0
  %endif

  %addtorecord block EtherCATTid InitEtherCATTask(block,system)
  %addtorecord block EtherCATSlaveId CompiledModel.EtherCAT.SlaveCount
  %assign CompiledModel.EtherCAT.SlaveCount = \
        CompiledModel.EtherCAT.SlaveCount + 1

  %foreach port = NumInputs
    %addtorecord block ECatInput { ...
          MapIdx 0 ...
          BitIdx 0 ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(InputPortSpec, "PDODataTypeId", port)) ...
          }
  %endforeach

  %assign FilterType = LibBlockSampleTime(block) == 0.0 ? 1 : 2

  %% Introduce the record FilterType to the block which defines what
  %% type of filter the block is working with. It is still unknown
  %% whether the block really uses a filter -- done later
  %% FilterType has 3 states:
  %%  0: Block does not use a filter
  %%  1: Block uses continuous filter
  %%  2: Block uses discrete filter
  %addtorecord block FilterType 0

  %assign FilterIdx = 0
  %foreach port = NumOutputs
    %addtorecord block ECatOutput { ...
          MapIdx 0 ...
          BitIdx 0 ...
          FilterIdx 0 ...
          FilterSpec GetIOPortSpec(OutputPortSpec, "Filter", port) ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(OutputPortSpec, "PDODataTypeId", port)) ...
          }
    %if ECatOutput[port].FilterSpec
      %% The output is filtered, so set the block's FilterType
      %assign block.FilterType = FilterType
      %assign block.ECatOutput[port].FilterIdx = FilterIdx
      %assign FilterIdx = FilterIdx + LibBlockOutputSignalWidth(port)
    %endif
  %endforeach

  %if EXISTS(SdoConfig)
    %addtorecord block SdoVar "sdo_config_%<EtherCATSlaveId>"
    %addtorecord block SdoConfigCount SIZE(SdoConfig)[0]

    %openfile buf

    /* SDO Configuration for Block: %<Name> */
    struct sdo_config %<SdoVar>[] = {
      %foreach i = SdoConfigCount
        { \
        %<GetDTypeName(SdoConfig[i][2])>, \
        %<SdoConfig[i][0]>, %<SdoConfig[i][1]>, %<SdoConfig[i][3]> \
        },
      %endforeach
    };
    %closefile buf
    %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
  %else
    %addtorecord block SdoVar "NULL"
    %addtorecord block SdoConfigCount 0
  %endif

  %% Setup the pdo_mapping structure. Every single block input and output, 
  %% be it a scalar or vector, has an entry in this array structure.
  %addtorecord block PdoVar "pdo_%<EtherCATSlaveId>"
  %addtorecord block PdoCount 0
  %openfile buf

    /* PDO Mapping for Block: %<Name> */
    struct pdo %<PdoVar>[] = {
    %%
    %assign MapIdx = 0
    %assign IWorkIdx = 0
    %foreach port = NumInputs
      /* Mapping for Input Port %<port+1> */
      %assign PDODataTypeId = GetIOPortSpec(InputPortSpec, "PDODataTypeId", port)
      %assign DstDType = GetDTypeName(PDODataTypeId)
      %assign ECatInput[port].MapIdx = MapIdx
      %assign ECatInput[port].BitIdx = IWorkIdx
      %assign PortWidth = LibBlockInputSignalWidth(port)
      %assign block.PdoCount = PdoCount + PortWidth
      %foreach sigIdx = PortWidth
        %if PDODataTypeId == tSS_BOOLEAN
          %assign BitOffsetAddr = "&%<LibBlockIWork(BitOffset,"","",IWorkIdx)>"
          %assign IWorkIdx = IWorkIdx + 1
        %else
          %assign BitOffsetAddr = "NULL"
        %endif
        %% PdoInfoIndex, PdoEntryIdx, PdoDataType
        { %<InputMap[MapIdx][0]>, \
          %<InputMap[MapIdx][1]>, \
          %<DstDType>, \
          %%
          %% Source address for the data. If floating point is used
          %% the source is the internal integer work vector, otherwise
          %% it is the signal memory location
          &%<LibBlockPWork(DataPtr,"","",MapIdx)>, \
          %<BitOffsetAddr> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    %%
    %assign InputMapMax = MapIdx
    %foreach port = NumOutputs
      /* Mapping for Output Port %<port+1> */
      %assign PDODataTypeId = GetIOPortSpec(OutputPortSpec, "PDODataTypeId", port)
      %assign SrcDType = GetDTypeName(PDODataTypeId)
      %assign ECatOutput[port].MapIdx = MapIdx
      %assign ECatOutput[port].BitIdx = IWorkIdx
      %assign PortWidth = LibBlockOutputSignalWidth(port)
      %assign block.PdoCount = PdoCount + PortWidth
      %foreach sigIdx = PortWidth
        %if PDODataTypeId == tSS_BOOLEAN
          %assign BitOffsetAddr = "&%<LibBlockIWork(BitOffset,"","",IWorkIdx)>"
          %assign IWorkIdx = IWorkIdx + 1
        %else
          %assign BitOffsetAddr = "NULL"
        %endif
        %% PdoInfoIndex, PdoEntryIdx, PdoDataType
        { %<OutputMap[MapIdx - InputMapMax][0]>, \
          %<OutputMap[MapIdx - InputMapMax][1]>, \
          %<SrcDType>, \
          %%
          %% Source address for the data. If floating point is used
          %% the source is the internal integer work vector, otherwise
          %% it is the signal memory location
          &%<LibBlockPWork(DataPtr,"","",MapIdx)>, \
          %<BitOffsetAddr> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Start(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Cache the C variable name that is assigned to this block defining
  %% the PDO Map
  %assign PDOMapId = GetPDOMapId(ProductName, VendorId, ProductCode, ...
                                 ProductRevision, PdoInfo, PdoEntryInfo)

  /* %<Type> Block: %<Name> 
   * Registering EtherCAT block %<ProductName> with Driver
   */
  if ((%<ETL.ErrStr> = ecs_reg_slave( \
           %<EtherCATTid>, \
           %<MasterId>, %<DomainId>, \
           %<SlaveAlias>, %<SlavePosition>, \
           %<VendorId>, %<ProductCode>, \
           %<SdoConfigCount>, %<SdoVar>, \
           %<PDOMapId>, \
           %<PdoCount>, %<PdoVar>))) {
        snprintf(%<ETL.ErrMsg>, sizeof(%<ETL.ErrMsg>), 
           "EtherCAT slave %<LibGetFormattedBlockPath(block)> register "
           "failed: %s", %<ETL.ErrStr>);
        %<LibSetRTModelErrorStatus( "%<ETL.ErrMsg>")>;
        return;
  }
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Outputs( block, system ) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if !NumOutputs
    %return
  %endif
  %%

  /* %<Type> Block: %<Name> */
  %%
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %% If the port is filtered, the output is the value of the filter's
      %% state variable
      %%
      %if RollRegions == []
        %assign ucv = ECatOutput[port].FilterIdx ...
                ? "i+%<ECatOutput[port].FilterIdx>" : "i"
        %if FilterType == 1
          %assign u0 = LibBlockContinuousState(ucv,"",0)
        %else
          %assign u0 = LibBlockDiscreteState(ucv,"",0)
        %endif
        %%
        { uint_T i;

          for (i = 0; i < %<PortWidth>; i++) {
            %<LibBlockOutputSignal(port,"i","",0)> = %<u0>;
          }
        }
      %else
        %assign RollVars = ["y%<port>"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                  "Roller", RollVars
          %%
          %assign FilterIdx = sigIdx + ECatOutput[port].FilterIdx
          %assign FilterLcv = ...
                (lcv != "" && FilterIdx) ? "%<lcv> + %<FilterIdx>" : lcv
          %%
          %if FilterType == 1
            %assign u0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
          %else
            %assign u0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
          %endif
          %%
          %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
        %endroll
      %endif
    %else
      %%
      %assign Raw   = GetIOPortSpec(OutputPortSpec, "Raw",   port)
      %assign PDODataTypeId = ...
                GetIOPortSpec(OutputPortSpec, "PDODataTypeId",  port)
      %if Raw
        /* Raw output port %<port+1> */
      %else
        /* Unfiltered output port %<port+1> */
      %endif
      %if PDODataTypeId == tSS_BOOLEAN
        %if RollRegions == []
          %assign srcUcv = "i+%<ECatOutput[port].MapIdx>"
          %assign shiftUcv = "i+%<ECatOutput[port].BitIdx>"
          %assign src = "*(uint8_T*)%<LibBlockPWork(DataPtr,srcUcv,"",0)>"
          %assign shift = LibBlockIWork(BitOffset,shiftUcv,"",0)
          { uint_T i;

            for (i = 0; i < %<PortWidth>; i++) {
              %<LibBlockOutputSignal(port,"i","",0)> = %<src> >> %<shift> & 1U;
            }
          }
        %else
          %assign RollVars = ["y%<port>", "<pwork>/DataPtr", ...
                "<iwork>/BitOffset"]
          %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
            %assign srcIdx = sigIdx + ECatOutput[port].MapIdx
            %assign shiftIdx = sigIdx + ECatOutput[port].BitIdx

            %assign srcLcv = (lcv != "" && srcIdx) ? "%<lcv>+%<srcIdx>" : lcv
            %assign shiftLcv = ...
                (lcv != "" && shiftIdx) ? "%<lcv>+%<shiftIdx>" : lcv
            %assign src = ...
                "*(uint8_T*)%<LibBlockPWork(DataPtr,"",srcLcv,srcIdx)>"
            %assign shift = LibBlockIWork(BitOffset,"",shiftLcv,shiftIdx)
            %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = \
                %<src> >> %<shift> & 1U;
          %endroll
        %endif
      %else
        %%
        %if RollRegions == []
          %assign PWorkUcv = "i+%<ECatOutput[port].MapIdx>"
          %assign u0 = GetSrc(port,PWorkUcv,"",0,"i","",0)
          %assign y0 = LibBlockOutputSignal(port,"i","",0)
          { uint_T i;

            for (i = 0; i < %<PortWidth>; i++) {
              %<y0> = %<u0>;
            }
          }
        %else
          %if Raw
            %assign RollVars = ["y%<port>", "<pwork>/DataPtr"]
          %else
            %assign RollVars = ["y%<port>", "<pwork>/DataPtr", ...
                  "<param>/%<OutputGainName[port]>", ...
                  "<param>/%<OutputOffsetName[port]>"]
          %endif
          %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                    "Roller", RollVars
            %%
            %assign PWorkIdx = sigIdx + ECatOutput[port].MapIdx
            %assign PWorkLcv = ...
                (lcv != "" && PWorkIdx) ? "%<lcv> + %<PWorkIdx>" : lcv
            %%
            %assign u0 = GetSrc(port,"",PWorkLcv,PWorkIdx,"",lcv,sigIdx)
            %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
          %endroll
        %endif
      %endif
    %endif
  %endforeach
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Update(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
  %if FilterType == 2 || NumInputs
    /* %<Type> Block: %<Name> */
  %endif
  %%
  %%
  %if FilterType == 2
    /* Discrete low pass filter */
    %<WriteFilter(block)>
  %endif
  %%
  %foreach port = NumInputs
    %if !LibBlockInputSignalConnected(port)
      %continue
    %endif
    /* Input port %<port+1> */
    %%
    %assign Raw  = GetIOPortSpec(InputPortSpec, "Raw",   port)
    %assign PDODataTypeId = GetIOPortSpec(InputPortSpec, "PDODataTypeId",  port)
    %assign PortWidth = LibBlockInputSignalWidth(port)
    %%
    %if PDODataTypeId == tSS_BOOLEAN
      %%
      %if RollRegions == []
        %assign dstUcv = ...
                ECatInput[port].MapIdx ? "i+%<ECatInput[port].MapIdx>" : "i"
        %assign dst = "*(uint8_T*)%<LibBlockPWork(DataPtr,dstUcv,"",0)>"
        %%
        %assign shiftUcv = ...
                ECatInput[port].BitIdx ? "i+%<ECatInput[port].BitIdx>" : "i"
        %assign shift = LibBlockIWork(BitOffset,shiftUcv,"",0)
        %assign mask = "~(1U << %<shift>)"
        %%
        %assign src = LibBlockInputSignal(port,"i","",0)
        { uint_T i;

          for (i = 0; i < %<PortWidth>; i++) {
            %<dst> = (%<dst> & %<mask>) | (%<src> & 1U) << %<shift>; 
          }
        }
      %else
        %assign RollVars = ["u%<port>", "<iwork>/BitOffset", "<pwork>/DataPtr"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign dstIdx = sigIdx + ECatInput[port].MapIdx
          %assign shiftIdx = sigIdx + ECatInput[port].BitIdx
          %assign dstLcv = (lcv != "" && dstIdx) ? "%<lcv>+%<dstIdx>" : lcv
          %assign shiftLcv = (lcv != "" && shiftIdx) ? "%<lcv>+%<shiftIdx>" : lcv
          %assign dst = "*(uint8_T*)%<LibBlockPWork(DataPtr,"",dstLcv,dstIdx)>"
          %assign shift = LibBlockIWork(BitOffset,"",shiftLcv,shiftIdx)
          %assign mask = "~(1U << %<shift>)"
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %<dst> = (%<dst> & %<mask>) | (%<src> & 1U) << %<shift>; 
        %endroll
      %endif
      %%
    %elseif Raw
      %if RollRegions == []
        { uint_T i;
        %assign src = LibBlockInputSignal(port,"i","",0)
        %assign PWorkUcv = ...
                ECatInput[port].MapIdx ? "i+%<ECatInput[port].MapIdx>" : "i"
        for (i = 0; i < %<PortWidth>; i++) {
          %<GetDst(port,PWorkUcv,"",0)> = %<src>;
        }
        }
      %else
        %assign RollVars = ["u%<port>", "<pwork>/DataPtr"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %assign PWorkIdx = sigIdx + ECatInput[port].MapIdx
          %assign PWorkLcv = ...
                (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
          %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<src>;
        %endroll
      %endif
    %else
      %assign FullScale = GetIOPortSpec(InputPortSpec, "PDOFullScale", port)
      %assign MaxValue = FullScale - 1.0
      %assign MinValue = ...
                GetIOPortSpec(InputPortSpec, "PDODataTypeSigned", port) ...
                ? -FullScale : 0.0
      { real_T value;
      %if RollRegions == []
        uint_T i;

        %assign src = LibBlockInputSignal(port,"i","",0)
        %assign PWorkUcv = ...
                ECatInput[port].MapIdx ? "i+%<ECatInput[port].MapIdx>" : "i"
        for (i = 0; i < %<PortWidth>; i++) {
          %if InputGainName[port] == ""
            value = %<src> * %<FullScale>;
          %else
            %assign scale = LibBlockParameter(%<InputGainName[port]>,"i","",0)
            value = %<src> * %<FullScale> * %<scale>;
          %endif
          if (value > %<MaxValue>) {
            %<GetDst(port,PWorkUcv,"",0)> = %<MaxValue>;
          } else if (value < %<MinValue>) {
            %<GetDst(port,PWorkUcv,"",0)> = %<MinValue>;
          } else {
            %<GetDst(port,PWorkUcv,"",0)> = value;
          }
        }
      %else

        %assign RollVars = ["u%<port>", "<pwork>/DataPtr", ...
                "<param>/%<InputGainName[port]>"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %assign PWorkIdx = sigIdx + ECatInput[port].MapIdx
          %assign PWorkLcv = (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
          %if InputGainName[port] == ""
            value = %<src> * %<FullScale>;
          %else
            %assign scale = ...
                LibBlockParameter(%<InputGainName[port]>,"",lcv,sigIdx)
            value = %<src> * %<FullScale> * %<scale>;
          %endif
          if (value > %<MaxValue>) {
            %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<MaxValue>;
          } else if (value < %<MinValue>) {
            %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<MinValue>;
          } else {
            %<GetDst(port,"",PWorkLcv,PWorkIdx)> = value;
          }
        %endroll
      %endif
      }
    %endif
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Derivatives(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if FilterType == 1
    /* %<Type> Block: %<Name> 
     * Continuous low pass filter
     */
    %<WriteFilter(block)>
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function WriteFilter(block) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %%
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %if RollRegions == []
        %assign PWorkUcv = ...
                ECatOutput[port].MapIdx ? "i+%<ECatOutput[port].MapIdx>" : "i"
        %assign u0 = GetSrc(port,PWorkUcv,"",0,"i","",0)
        %assign k  = LibBlockParameter(%<OutputFilterName[port]>,"i","",0)
        %assign FilterUcv = ECatOutput[port].FilterIdx ...
                ? "i+%<ECatOutput[port].FilterIdx>" : "i"
        { uint_T i;

          for (i = 0; i < %<PortWidth>; i++) {
          %if FilterType == 1
            %assign y0 = LibBlockContinuousState(FilterUcv,"",0)
            %assign d0 = LibBlockContinuousStateDerivative(FilterUcv,"",0)
            %%
            %% The following is equivalent to:
            %%   <d0> = %<k>*(%<u0>) + (1 - %<k>)*%<d0>;
            %<d0>  = %<k>*(%<u0> - %<y0>);
          %else
            %assign d0 = LibBlockDiscreteState(FilterUcv,"",0)
            %<d0> += %<k>*(%<u0> - %<d0>);
          %endif
          }
        }
      %else
        %assign RollVars = ["<param>/%<OutputGainName[port]>", ...
                  "<param>/%<OutputOffsetName[port]>", ...
                  "<param>/%<OutputFilterName[port]>", "<pwork>/DataPtr"]
        %%
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                  "Roller", RollVars
          %%
          %assign PWorkIdx = sigIdx + ECatOutput[port].MapIdx
          %assign FilterIdx = sigIdx + ECatOutput[port].FilterIdx
          %assign PWorkLcv = (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
          %assign FilterLcv = ...
                (lcv != "" && FilterIdx) ? "%<lcv>+%<FilterIdx>" : lcv
          %%
          %assign u0 = GetSrc(port,"",PWorkLcv,PWorkIdx,"",lcv,sigIdx)
          %assign k  = LibBlockParameter(%<OutputFilterName[port]>,"",lcv,sigIdx)
          %if FilterType == 1
            %assign y0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
            %assign d0 = LibBlockContinuousStateDerivative("",FilterLcv,FilterIdx)
            %%
            %% The following is equivalent to:
            %%   <d0> = %<k>*(%<u0>) + (1 - %<k>)*%<d0>;
            %<d0>  = %<k> * (%<u0> - %<y0>);
          %else
            %assign d0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
            %<d0> += %<k> * (%<u0> - %<d0>);
          %endif
        %endroll
      %endif
    %endif
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDst(port, PWorkUcv, PWorkLcv, PWorkIdx)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %return SPRINTF("*(%s*)(%s)", ...
      ECatInput[port].RTWDType, ...
      LibBlockPWork(DataPtr, PWorkUcv, PWorkLcv, PWorkIdx) ...
      )

%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetSrc(port, PWorkUcv, PWorkLcv, PWorkIdx, ...
        GainUcv, GainLcv, GainIdx) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %assign src = SPRINTF("*(%s*)(%s)", ...
       ECatOutput[port].RTWDType, ...
       LibBlockPWork(DataPtr,PWorkUcv,PWorkLcv,PWorkIdx))

  %if GetIOPortSpec(OutputPortSpec, "Raw",   port)
    %return src
  %endif

  %assign GainType   = GetIOPortSpec(OutputPortSpec, "Gain",   port)
  %assign OffsetType = GetIOPortSpec(OutputPortSpec, "Offset", port)
  %assign src = SPRINTF("*(%s*)(%s)/%.1f", ...
       ECatOutput[port].RTWDType, ...
       LibBlockPWork(DataPtr,PWorkUcv,PWorkLcv,PWorkIdx), ...
       GetIOPortSpec(OutputPortSpec, "PDOFullScale", port))

  %assign u0 = src
  %if GainType
    %assign gain = LibBlockParameter(...
          %<OutputGainName[port]>,GainUcv,GainLcv,GainIdx)
    %assign u0 = "%<gain>*%<u0>"
  %endif
  %if OffsetType
    %assign offset = LibBlockParameter( ...
          %<OutputOffsetName[port]>,GainUcv,GainLcv,GainIdx)
    %assign u0 = "%<u0> + %<offset>"
  %endif

  %return u0
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetPDOMapId( name, vendorId, prodCode, revision, \
        pdoMap, pdoEntryInfo) void
%% 
%% This function is used to define variables that are required to specify
%% the pdo mapping of an EtherCAT slave. The string that is returned
%% is the variable name that should be used when calling 
%% ecrt_slave_config_pdos()
%% Parameters:
%%   name       string  Common name of the slave
%%   vendorId   int     Vendor Identification number
%%   prodCode   int     Product Code of the slave
%%   revision   int     Revision code of the slave
%%   pdoMap        This is a vector of integers organised in groups of 4:
%%                   entry0:    1 = Input; 0 = Output
%%                   entry1:    Index of PDO to map
%%                   entry2:    Group index of pdoEntryInfo
%%                   entry3:    Number of pdoEntryInfo groups
%%   pdoEntryInfo  This is a vector of integers organised in groups of 3:
%%                   entry0:    Index of the PDO
%%                   entry1:    Subindex of the PDO
%%                   entry2:    PDO bit length
%%                   entry3:    PDO value is signed
%%
%% A typical value for pdoEntryInfo is:
%%      [[ 0x3101, 1,  8, 0 ],   <- Group 0
%%       [ 0x3101, 2, 16, 0 ],   <- Group 1
%%       [ 0x3102, 1,  8, 0 ],   <- Group 2
%%       [ 0x3102, 2, 16, 1 ]]   <- Group 3
%% describing the PDO entry information for the el31xx series. Here
%% are 4 groups of 3 values.
%%
%% A typical value for pdoMap is:
%%     [[ 1,       <- Input
%%        0x1A00,  <- Pdo Index to map
%%        0,       <- starting with group[0] of pdoEntryInfo
%%        2     ], <- going on for 2 groups (i.e. group[0] and group[1])
%%
%%      [ 1, 0x1A01 2, 2 ]] <- Second group entry of pdoMap, mapping 0x1A01
%%                             to group[2] and group[3] of pdoEntryInfo
%%                             (indices [6..11])
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %assign suffix = SPRINTF("0x%08x_0x%08x_0x%08x", vendorId, prodCode, revision)
  %assign varName = "pdo_info_%<suffix>"
  %if ISFIELD(CompiledModel.EtherCAT.PDOMap,varName)
    %return varName
  %endif
  %addtorecord CompiledModel.EtherCAT.PDOMap %<varName> 1

  %assign PdoEntryInfoId = "pdo_entry_info_%<suffix>"
  %openfile buf
  /* PDO Mapping for %<name> Rev. %<revision> */
  ec_pdo_entry_info_t %<PdoEntryInfoId>[] = {
  %foreach i = SIZE(pdoEntryInfo)[0]
    %<SPRINTF("{ 0x%04X, %u, %u }, /* %u */", pdoEntryInfo[i][0], ...
        pdoEntryInfo[i][1], pdoEntryInfo[i][2], i)>
  %endforeach
  };
  ec_pdo_info_t %<varName>[] = {
  %foreach i = SIZE(pdoMap)[0]
    { \
    %% The value 0 or 1 indicates a simulink block output or input
    %% respectively. This in turn maps to EC_DIR_INPUT and EC_DIR_OUTPUT
    %% as far as the EtherCAT master is concerned.
    %% i.e. 0 -> block output -> EC_DIR_INPUT  -> Slave TxPDO
    %%      1 -> block input  -> EC_DIR_OUTPUT -> Slave RxPDO
    %%                                                       
    %%              Simulink Block                         
    %%              +-------------------------------+
    %%              |         EtherCAT Master       |       
    %%              |                               |       
    %%              |          +---------+          |       
    %%  pdoMap[][0] |   EC_DIR |Slave    | EC_DIR   | pdoMap[][0]
    %%          = 1 |   OUTPUT |         | INPUT    | = 0      
    %%         ----->----------> Rx   Tx >---------->-----  
    %%              |          |   PDO   |          |      
    %%              |          |         |          |      
    %%              |          +---------+          |      
    %%              | output domain                 |      
    %%              |                  input domain |      
    %%              +-------------------------------+      
    %%
    %if pdoMap[i][0] == 0
      %% simulink block output
      EC_DIR_INPUT, \
    %else
      %% simulink block input
      EC_DIR_OUTPUT, \
    %endif
    %<SPRINTF("0x%04X, %u", pdoMap[i][1], pdoMap[i][3])>, \
    &%<PdoEntryInfoId>[%<pdoMap[i][2]>] },
    %if SIZE(pdoEntryInfo)[0] < pdoMap[i][2] + pdoMap[i][3]
       %error ############# Error creating PDO map for %<name> for block ...
              %<LibGetFormattedBlockPath(block)>: ...
             struct ec_pdo_entry_info_t only has %<SIZE(pdoEntryInfo)[0]> ...
             elements, whereas you requested to map element ...
             %<pdoMap[i][2] + pdoMap[i][3]>. This will cause a segv!
              #############
    %endif
  %endforeach
  { EC_END, },
  };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
        "Definitions", buf)>

  %return varName
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetIOPortSpec( Spec, Entry, Port ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %switch Entry
    %case "PDODataTypeId"
      %return Spec[Port][0]
    %case "PDODataTypeName"
      %return GetDTypeName(Spec[Port][0])
    %case "PDODataTypeSigned"
      %return GetDTypeSigned(Spec[Port][0])
    %case "Raw"
      %return Spec[Port][1]
    %case "PDOFullScale"
      %return FEVAL("pow2",Spec[Port][2])
    %case "Gain"
      %return Spec[Port][3]
    %case "Offset"
      %return Spec[Port][4]
    %case "Filter"
      %return Spec[Port][5]
    %default
      %error Unknown request %<Entry> for GetIOPortSpec()
  %endswitch

%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeSigned( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_BOOLEAN
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
      %return 0

    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %return 1

    %default
      %error Unknown PDODataType: %<dtype>
  %endswitch
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeName( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_BOOLEAN
      %return "si_boolean_T"
    %case tSS_UINT8
      %return "si_uint8_T"
    %case tSS_INT8
      %return "si_sint8_T"
    %case tSS_UINT16
      %return "si_uint16_T"
    %case tSS_INT16
      %return "si_sint16_T"
    %case tSS_UINT32
      %return "si_uint32_T"
    %case tSS_INT32
      %return "si_sint32_T"
    %default
      %error Unknown PDODataType: %<dtype>; Known types: ...
                %<tSS_UINT8> %<tSS_INT8> %<tSS_UINT16> %<tSS_INT16> ...
                %<tSS_UINT32> %<tSS_INT32> %<tSS_BOOLEAN>
  %endswitch
%endfunction
