%implements "ec_slave" "C"

%%
%% Hardware Driver for Beckhoff's EtherCAT Analog Input Terminal
%% series EL31xx
%% 
%% This TLC Implements the necessary IO Functions to communicate
%% with the EtherCAT Driver enabling the usage of a analog input
%% terminal.
%%
%% Copyright (C) 2006
%% Richard Hacker
%% IgH Essen GmbH
%% 
%% License: GPL

%include "EtherCAT.tlc"

%% FIXME: Bit operations for block outputs are still wrong

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockTypeSetup( block, system ) void
%% This function checks whether the EtherCAT system has been called once
%% before already, which is demonstrated by the existance of variable 
%% ::EtherCAT. If not, include C-header file for EtherCAT, 
%% and declare a variable where the slave's data structure is placed 
%% by EtherCAT when registering the slaves during mdlStart()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %<InitEtherCAT()>
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockInstanceSetup( block, system ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if EXISTS(InputPortSpec)
    %assign nm = SIZE(InputPortSpec)
    %if nm[1] > 0 && nm[1] != 4
      %error Unexpected column count for InputPortSpec %<InputPortSpec>
    %endif
    %addtorecord block NumInputs nm[0]
  %else
    %addtorecord block NumInputs 0
  %endif

  %if EXISTS(OutputPortSpec)
    %assign nm = SIZE(OutputPortSpec)
    %if nm[1] > 0 && nm[1] != 6
      %error Unexpected column count for OutputPortSpec %<OutputPortSpec>
    %endif
    %addtorecord block NumOutputs nm[0]
  %else
    %addtorecord block NumOutputs nm[0]
  %endif

  %addtorecord block EtherCATTid InitEtherCATTask(block,system)
  %addtorecord block EtherCATSlaveId CompiledModel.EtherCAT.SlaveCount
  %assign CompiledModel.EtherCAT.SlaveCount = \
        CompiledModel.EtherCAT.SlaveCount + 1

  %% Cache the C variable name that is assigned to this block defining
  %% the PDO Map
  %addtorecord block PDOMapId ...
      GetPDOMapId(ProductName, VendorId, ProductCode, ProductRevision, ...
                  PdoInfo, PdoEntryInfo)

  %foreach i = NumInputs
    %addtorecord block ECatInput { ...
          DstDType GetIOPortSpec(InputPortSpec, "PDODataTypeName", i) ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(InputPortSpec, "PDODataTypeId", i)) ...
          }
  %endforeach

  %assign FilterType = LibBlockSampleTime(block) == 0.0 ? 1 : 2

  %% Introduce the record FilterType to the block which defines what
  %% type of filter the block is working with. It is still unknown
  %% whether the block really uses a filter -- done later
  %% FilterType has 3 states:
  %%  0: Block does not use a filter
  %%  1: Block uses continuous filter
  %%  2: Block uses discrete filter
  %addtorecord block FilterType 0

  %foreach i = NumOutputs
    %addtorecord block ECatOutput { ...
          FilterSpec GetIOPortSpec(OutputPortSpec, "Filter", i) ...
          SrcDType GetIOPortSpec(OutputPortSpec, "PDODataTypeName", i) ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(OutputPortSpec, "PDODataTypeId", i)) ...
          }
    %if ECatOutput[i].FilterSpec
      %% The output is filtered, so set the block's FilterType
      %assign block.FilterType = FilterType
    %endif
  %endforeach

  %if EXISTS(SdoConfig)
    %addtorecord block SdoVar "sdo_config_%<EtherCATSlaveId>"
    %addtorecord block SdoConfigCount SIZE(SdoConfig)[0]

    %openfile buf

    /* SDO Configuration for Block: %<Name> */
    struct sdo_config %<SdoVar>[] = {
      %foreach i = SdoConfigCount
        { \
        %<GetDTypeName(SdoConfig[i][2])>, \
        %<SdoConfig[i][0]>, %<SdoConfig[i][1]>, %<SdoConfig[i][3]> \
        },
      %endforeach
    };
    %closefile buf
    %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
  %else
    %addtorecord block SdoVar "NULL"
    %addtorecord block SdoConfigCount 0
  %endif

  %% Setup the pdo_mapping structure. Every single block input and output, 
  %% be it a scalar or vector, has an entry in this array structure.
  %addtorecord block PdoMappingVar "pdo_mapping_%<EtherCATSlaveId>"
  %addtorecord block PdoMappingCount 0
  %openfile buf

    /* PDO Mapping for Block: %<Name> */
    struct pdo_mapping %<PdoMappingVar>[] = {
    %%
    %assign MapIdx = 0
    %foreach port = NumInputs
      /* Mapping for Input Port %<port+1> */
      %assign count = GetIOPortSpec(InputPortSpec, "Bits", port) ...
                ? 1 : LibBlockInputSignalWidth(port)
      %foreach j = count
        %assign block.PdoMappingCount = PdoMappingCount + 1
        %% PdoInfoIndex, PdoEntryIdx, PdoDataType
        { %<InputMap[MapIdx][0]>, \
          %<InputMap[MapIdx][1]>, \
          %<ECatInput[port].DstDType>, \
        %%
        %% Source address for the data. If floating point is used
        %% the source is the internal integer work vector, otherwise
        %% it is the signal memory location
        &%<LibBlockPWork(DstPtr,"","",MapIdx)> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    %%
    %assign MapIdx = 0
    %foreach port = NumOutputs
      /* Mapping for Output Port %<port+1> */
      %assign count = GetIOPortSpec(OutputPortSpec, "Bits", port) ...
                ? 1 : LibBlockOutputSignalWidth(port)
      %foreach j = count
        %assign block.PdoMappingCount = PdoMappingCount + 1
        %assign ptr = LibBlockPWork(SrcPtr,"","",10)
        %% PdoInfoIndex, PdoEntryIdx, PdoDataType
        { %<OutputMap[MapIdx][0]>, \
          %<OutputMap[MapIdx][1]>, \
          %<ECatOutput[port].SrcDType>, \
        %%
        %% Source address for the data. If floating point is used
        %% the source is the internal integer work vector, otherwise
        %% it is the signal memory location
        &%<LibBlockPWork(SrcPtr,"","",MapIdx)> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Start(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  /* %<Type> Block: %<Name> 
   * Registering EtherCAT block %<ProductName> with Driver
   */
  if ((%<ETL.ErrStr> = ecs_reg_slave( \
           %<EtherCATTid>, \
           %<MasterId>, %<DomainId>, \
           %<SlaveAlias>, %<SlavePosition>, \
           %<VendorId>, %<ProductCode>, \
           %<SdoConfigCount>, %<SdoVar>, \
           %<PDOMapId>, \
           %<PdoMappingCount>, %<PdoMappingVar>))) {
        snprintf(%<ETL.ErrMsg>, sizeof(%<ETL.ErrMsg>), 
           "EtherCAT slave %<LibGetFormattedBlockPath(block)> register "
           "failed: %s", %<ETL.ErrStr>);
        %<LibSetRTModelErrorStatus( "%<ETL.ErrMsg>")>;
        return;
  }
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Outputs( block, system ) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if !NumOutputs
    %return
  %endif
  %%

  /* %<Type> Block: %<Name> */
  %%
  %assign FilterIdxOffset = 0
  %assign PWorkIdxOffset = 0
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %% If the port is filtered, the output is the value of the filter's
      %% state variable
      %%
      %if RollRegions == []
        %if FilterIdxOffset == 0
          %assign ucv = "i"
        %else
          %assign ucv = "i+%<FilterIdxOffset>"
        %endif
        %if FilterType == 1
          %assign u0 = LibBlockContinuousState(ucv,"",0)
        %else
          %assign u0 = LibBlockDiscreteState(ucv,"",0)
        %endif
        %%
        {
          int_T i;

          for (i = 0; i < %<PortWidth>; i++) {
            %<LibBlockOutputSignal(port,"i","",0)> = %<u0>;
          }
        }
      %else
        %assign RollVars = ["y%<port>"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                  "Roller", RollVars
          %%
          %assign FilterIdx = sigIdx + FilterIdxOffset
          %assign FilterLcv = lcv
          %if FilterIdx && FilterLcv != ""
            %assign FilterLcv = "%<FilterLcv> + %<FilterIdx>"
          %endif
          %%
          %if FilterType == 1
            %assign u0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
          %else
            %assign u0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
          %endif
          %%
          %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
        %endroll
      %endif
      %assign FilterIdxOffset = FilterIdxOffset + PortWidth
      %assign PWorkIdxOffset = PWorkIdxOffset + PortWidth
    %else
      %%
      %assign Raw   = GetIOPortSpec(OutputPortSpec, "Raw",   port)
      %assign Bits  = GetIOPortSpec(OutputPortSpec, "Bits",  port)
      %if Raw
        /* Raw output port %<port+1> */
      %else
        /* Unfiltered output port %<port+1> */
      %endif
      %if Bits
        %assign Mask = (1U << Bits) - 1
        %assign u0 = GetSrc(port,"","",PWorkIdxOffset,"","",0)
        %assign PWorkIdxOffset = PWorkIdxOffset + 1
        { %<ECatOutput[port].RTWDType> value = %<u0>;
        %if RollRegions == []
          int_T i;

          for (i = 0; i < %<PortWidth>; i++) {
            %<LibBlockOutputSignal(port,"i","",0)> = ...
                value >> (%<Bits>*i) & %<Mask>;
          }
        %else
          %assign RollVars = ["y%<port>"]
          %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
            %if lcv == ""
              %assign shift = sigIdx * Bits
            %else
              %if sigIdx == 0
                %assign shift = "(%<lcv>*%<Bits>)"
              %else
                %assign shift = "((%<lcv>+%<sigIdx>)*%<Bits>)"
              %endif
            %endif
            %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = ...
                value >> %<shift> & %<Mask>;
          %endroll
        %endif
        }
      %else
        %%
        %if RollRegions == []
          %if PWorkIdxOffset == 0
            %assign PWorkUcv = "i"
          %else
            %assign PWorkUcv = "i+%<PWorkIdxOffset>"
          %endif
          %assign u0 = GetSrc(port,PWorkUcv,"",0,"i","",0)
          %assign y0 = LibBlockOutputSignal(port,"i","",0)
          { 
            int_T i;

            for (i = 0; i < %<PortWidth>; i++) {
              %<y0> = %<u0>;
            }
          }
        %else
          %if Raw
            %assign RollVars = ["y%<port>", "<pwork>/SrcPtr"]
          %else
            %assign RollVars = ["y%<port>", "<pwork>/SrcPtr", ...
                  "<param>/%<OutputGainName[port]>", ...
                  "<param>/%<OutputOffsetName[port]>"]
          %endif
          %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                    "Roller", RollVars
            %%
            %assign PWorkIdx = sigIdx + PWorkIdxOffset
            %assign PWorkLcv = lcv
            %if PWorkIdx && PWorkLcv != ""
              %assign PWorkLcv = "%<PWorkLcv> + %<PWorkIdx>"
            %endif
            %%
            %assign u0 = GetSrc(port,"",PWorkLcv,PWorkIdx,"",lcv,sigIdx)
            %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
          %endroll
        %endif
        %assign PWorkIdxOffset = PWorkIdxOffset + PortWidth
      %endif
    %endif
  %endforeach
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Update(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
    %trace FilterType %<FilterType>
  %if FilterType == 2 || NumInputs
    /* %<Type> Block: %<Name> */
  %endif
  %%
  %%
  %if FilterType == 2
    /* Discrete low pass filter */
    %<WriteFilter(block)>
  %endif
  %%
  %assign PWorkIdxOffset = 0
  %foreach port = NumInputs
    %if !LibBlockInputSignalConnected(port)
      %continue
    %endif
    /* Input port %<port+1> */
    %%
    %assign Raw  = GetIOPortSpec(InputPortSpec, "Raw",   port)
    %assign Bits = GetIOPortSpec(InputPortSpec, "Bits",  port)
    %assign PortWidth = LibBlockInputSignalWidth(port)
    %assign Mask = (1U << Bits) - 1
    %%
    %if Bits
      { %<ECatInput[port].RTWDType> value = 0;
      %%
      %if RollRegions == []
        %assign src = LibBlockInputSignal(port,"i","",0)
        int_T i;

        for (i = 0; i < %<PortWidth>; i++) {
          value |= ((%<ECatInput[port].RTWDType>)%<src> & %<Mask>) \
                        << (i*%<Bits>);
        }
      %else
        %assign RollVars = ["u%<port>"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          value |= ((%<ECatInput[port].RTWDType>)%<src> & %<Mask>) \
                        << (i*%<Bits>);
        %endroll
      %endif
      %<GetDst(port,"","",PWorkIdxOffset)> = value;
      %assign PWorkIdxOffset = PWorkIdxOffset + 1
      }
      %%
    %elseif Raw
      %if RollRegions == []
        { int_T i;
        %assign src = LibBlockInputSignal(port,"i","",0)
        %assign PWorkUcv = PWorkIdxOffset ? "i+%<PWorkIdxOffset>" : "i"
        for (i = 0; i < %<PortWidth>; i++) {
          %<GetDst(port,PWorkUcv,"",0)> = %<src>;
        }
        }
      %else
        %assign RollVars = ["u%<port>", "<pwork>/DstPtr"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %assign PWorkIdx = sigIdx + PWorkIdxOffset
          %assign PWorkLcv = lcv
          %if lcv != "" && PWorkIdx
            %assign PWorkLcv = "%<PWorkLcv>+%<PWorkIdx>"
          %endif
          %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<src>;
        %endroll
      %endif
      %assign PWorkIdxOffset = PWorkIdxOffset + PortWidth
    %else
      %assign FullScale = GetIOPortSpec(InputPortSpec, "PDOFullScale", port)
      %assign MaxValue = FullScale - 1.0
      %assign MinValue = ...
                GetIOPortSpec(InputPortSpec, "PDODataTypeSigned", port) ...
                ? -FullScale : 0.0
      { real_T value;
      %if RollRegions == []
        int_T i;

        %assign src = LibBlockInputSignal(port,"i","",0)
        %assign scale = LibBlockParameter(%<InputGainName[port]>,"i","",0)
        %assign PWorkUcv = PWorkIdxOffset ? "i+%<PWorkIdxOffset>" : "i"
        for (i = 0; i < %<PortWidth>; i++) {
          value = %<src> * %<FullScale> * %<scale>;
          if (value > %<MaxValue>) {
            %<GetDst(port,PWorkUcv,"",0)> = %<MaxValue>;
          } else if (value < %<MinValue>) {
            %<GetDst(port,PWorkUcv,"",0)> = %<MinValue>;
          } else {
            %<GetDst(port,PWorkUcv,"",0)> = value;
          }
        }
      %else

        %assign RollVars = ["u%<port>", "<pwork>/DstPtr", ...
                "<param>/%<InputGainName[port]>"]
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %assign scale = ...
              LibBlockParameter(%<InputGainName[port]>,"",lcv,sigIdx)
          %assign PWorkIdx = sigIdx + PWorkIdxOffset
          %assign PWorkLcv = lcv
          %if lcv != "" && PWorkIdx
            %assign PWorkLcv = "%<PWorkLcv>+%<PWorkIdx>"
          %endif
          value = %<src> * %<FullScale> * %<scale>;
          if (value > %<MaxValue>)
            %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<MaxValue>;
          else if (value < %<MinValue>)
            %<GetDst(port,"",PWorkLcv,PWorkIdx)> = %<MinValue>;
          else
            %<GetDst(port,"",PWorkLcv,PWorkIdxcv)> = value;
        %endroll
      %endif
      }
      %assign PWorkIdxOffset = PWorkIdxOffset + PortWidth
    %endif
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Derivatives(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if FilterType == 1
    /* %<Type> Block: %<Name> 
     * Continuous low pass filter
     */
    %<WriteFilter(block)>
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function WriteFilter(block) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
  %assign FilterIdxOffset = 0
  %assign PWorkIdxOffset = 0
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %%
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %if RollRegions == []
        %assign PWorkUcv = "i+%<PWorkIdxOffset>"
        %assign u0 = GetSrc(port,PWorkUcv,"",0,"i","",0)
        %assign k  = LibBlockParameter(%<OutputFilterName[port]>,"i","",0)
        %if FilterIdxOffset == 0
          %assign FilterUcv = "i"
        %else
          %assign FilterUcv = "i + %<FilterIdxOffset>"
        %endif
        {
          int_T i;

          for (i = 0; i < %<PortWidth>; i++) {
          %if FilterType == 1
            %assign y0 = LibBlockContinuousState(FilterUcv,"",0)
            %assign d0 = LibBlockContinuousStateDerivative(FilterUcv,"",0)
            %%
            %% The following is equivalent to:
            %%   <d0> = %<k>*(%<u0>) + (1 - %<k>)*%<d0>;
            %<d0>  = %<k>*(%<u0> - %<y0>);
          %else
            %assign d0 = LibBlockDiscreteState(FilterUcv,"",0)
            %<d0> += %<k>*(%<u0> - %<d0>);
          %endif
          }
        }
      %else
        %assign RollVars = ["<param>/%<OutputGainName[port]>", ...
                  "<param>/%<OutputOffsetName[port]>", ...
                  "<param>/%<OutputFilterName[port]>", "<pwork>/SrcPtr"]
        %%
        %roll sigIdx = RollRegions, lcv = RollThreshold, block, ...
                  "Roller", RollVars
          %%
          %assign PWorkIdx = sigIdx + PWorkIdxOffset
          %assign FilterIdx = sigIdx + FilterIdxOffset
          %assign PWorkLcv = lcv
          %assign FilterLcv = lcv
          %if lcv != ""
            %if PWorkIdx
              %assign PWorkLcv = "%<PWorkLcv>+%<PWorkIdx>"
            %endif
            %if FilterIdx
              %assign FilterLcv = "%<FilterLcv>+%<FilterIdx>"
            %endif
          %else
          %endif
          %%
          %assign u0 = GetSrc(port,"",PWorkLcv,PWorkIdx,"",lcv,sigIdx)
          %assign k  = LibBlockParameter( ...
                  %<OutputFilterName[port]>,"",lcv,sigIdx)
          %if FilterType == 1
            %assign y0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
            %assign d0 = LibBlockContinuousStateDerivative("",FilterLcv,FilterIdx)
            %%
            %% The following is equivalent to:
            %%   <d0> = %<k>*(%<u0>) + (1 - %<k>)*%<d0>;
            %<d0>  = %<k> * (%<u0> - %<y0>);
          %else
            %assign d0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
            %<d0> += %<k> * (%<u0> - %<d0>);
          %endif
        %endroll
      %endif
      %assign FilterIdxOffset = FilterIdxOffset + PortWidth
    %endif
    %assign PWorkIdxOffset = PWorkIdxOffset + ...
        (GetIOPortSpec(OutputPortSpec, "Bits", port) ? 1 : PortWidth)
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDst(port, PWorkUcv, PWorkLcv, PWorkIdx)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %return SPRINTF("*(%s*)(%s)", ...
      ECatInput[port].RTWDType, ...
      LibBlockPWork(DstPtr, PWorkUcv, PWorkLcv, PWorkIdx) ...
      )

%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetSrc(port, PWorkUcv, PWorkLcv, PWorkIdx, ...
        GainUcv, GainLcv, GainIdx) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %assign src = SPRINTF("*(%s*)(%s)", ...
       ECatOutput[port].RTWDType, ...
       LibBlockPWork(SrcPtr,PWorkUcv,PWorkLcv,PWorkIdx))

  %if GetIOPortSpec(OutputPortSpec, "Raw",   port)
    %return src
  %endif

  %assign GainType   = GetIOPortSpec(OutputPortSpec, "Gain",   port)
  %assign OffsetType = GetIOPortSpec(OutputPortSpec, "Offset", port)
  %assign src = SPRINTF("*(%s*)(%s)/%.1f", ...
       ECatOutput[port].RTWDType, ...
       LibBlockPWork(SrcPtr,PWorkUcv,PWorkLcv,PWorkIdx), ...
       GetIOPortSpec(OutputPortSpec, "PDOFullScale", port))

  %if GainType || OffsetType
    %assign gain = LibBlockParameter(...
          %<OutputGainName[port]>,GainUcv,GainLcv,GainIdx)
    %assign offset = LibBlockParameter( ...
          %<OutputOffsetName[port]>,GainUcv,GainLcv,GainIdx)
    %assign u0 = "%<gain>*%<src> + %<offset>"
  %else
    %assign u0 = src
  %endif

  %return u0
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetPDOMapId( name, vendorId, prodCode, revision, \
        pdoMap, pdoEntryInfo) void
%% 
%% This function is used to define variables that are required to specify
%% the pdo mapping of an EtherCAT slave. The string that is returned
%% is the variable name that should be used when calling 
%% ecrt_slave_config_pdos()
%% Parameters:
%%   name       string  Common name of the slave
%%   vendorId   int     Vendor Identification number
%%   prodCode   int     Product Code of the slave
%%   revision   int     Revision code of the slave
%%   pdoMap        This is a vector of integers organised in groups of 4:
%%                   entry0:    1 = Input; 0 = Output
%%                   entry1:    Index of PDO to map
%%                   entry2:    Group index of pdoEntryInfo
%%                   entry3:    Number of pdoEntryInfo groups
%%   pdoEntryInfo  This is a vector of integers organised in groups of 3:
%%                   entry0:    Index of the PDO
%%                   entry1:    Subindex of the PDO
%%                   entry2:    PDO bit length
%%
%% A typical value for pdoEntryInfo is:
%%      [ 0x3101, 1, 8,    <- Group 0
%%        0x3101, 2, 16,   <- Group 1
%%        0x3102, 1, 8,    <- Group 2
%%        0x3102, 2, 16 ]  <- Group 3
%% describing the PDO entry information for the el31xx series. Here
%% are 4 groups of 3 values.
%%
%% A typical value for pdoMap is:
%%     [ 1,       <- Input
%%       0x1A00,  <- Pdo Index to map
%%       0,       <- starting with group[0] of pdoEntryInfo
%%       2,       <- going on for 2 groups (i.e. group[0] and group[1])
%%
%%       1, 0x1A01 2, 2 ] <- Second group entry of pdoMap, mapping 0x1A01
%%                           to group[2] and group[3] of pdoEntryInfo
%%                           (indices [6..11])
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %assign suffix = SPRINTF("0x%08x_0x%08x_%u", vendorId, prodCode, revision)
  %assign varName = "pdos_%<suffix>"
  %if ISFIELD(CompiledModel.EtherCAT.PDOMap,varName)
    %return varName
  %endif
  %addtorecord CompiledModel.EtherCAT.PDOMap %<varName> 1

  %assign PdoEntryInfoId = "pdo_entry_info_%<suffix>"
  %openfile buf
  /* PDO Mapping for %<name> Rev. %<revision> */
  ec_pdo_entry_info_t %<PdoEntryInfoId>[] = {
  %foreach i = SIZE(pdoEntryInfo)[0]
    { \
    %foreach j = 3
      %<pdoEntryInfo[i][j]>, \
    %endforeach
    },
  %endforeach
  };
  ec_pdo_info_t %<varName>[] = {
  %foreach i = SIZE(pdoMap)[0]
    { \
    %% The value 0 or 1 indicates a simulink block output or input
    %% respectively. This in turn maps to EC_DIR_INPUT and EC_DIR_OUTPUT
    %% as far as the EtherCAT master is concerned.
    %% i.e. 0 -> block output -> EC_DIR_INPUT  -> Slave TxPDO
    %%      1 -> block input  -> EC_DIR_OUTPUT -> Slave RxPDO
    %%                                                       
    %%              Simulink Block                         
    %%              +-------------------------------+
    %%              |         EtherCAT Master       |       
    %%              |                               |       
    %%              |          +---------+          |       
    %%  pdoMap[][0] |   EC_DIR |Slave    | EC_DIR   | pdoMap[][0]
    %%          = 1 |   OUTPUT |         | INPUT    | = 0      
    %%         ----->----------> Rx   Tx >---------->-----  
    %%              |          |   PDO   |          |      
    %%              |          |         |          |      
    %%              |          +---------+          |      
    %%              | output domain                 |      
    %%              |                  input domain |      
    %%              +-------------------------------+      
    %%
    %if pdoMap[i][0] == 0
      %% simulink block output
      EC_DIR_INPUT, \
    %else
      %% simulink block input
      EC_DIR_OUTPUT, \
    %endif
    %<pdoMap[i][1]>, %<pdoMap[i][3]>, &%<PdoEntryInfoId>[%<pdoMap[i][2]>] },
    %if SIZE(pdoEntryInfo)[0] < pdoMap[i][2] + pdoMap[i][3]
       %error ############# Error creating PDO map for %<name> for block ...
              %<LibGetFormattedBlockPath(block)>: ...
             struct ec_pdo_entry_info_t only has %<SIZE(pdoEntryInfo)[0]> ...
             elements, whereas you requested to map element ...
             %<pdoMap[i][2] + pdoMap[i][3]>. This will cause a segv!
              #############
    %endif
  %endforeach
  { EC_END, },
  };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
        "Definitions", buf)>

  %return varName
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetIOPortSpec( Spec, Entry, Port ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %switch Entry
    %case "PDODataTypeId"
      %return Spec[Port][0]
    %case "PDODataTypeName"
      %return GetDTypeName(Spec[Port][0])
    %case "PDODataTypeSigned"
      %return GetDTypeSigned(Spec[Port][0])
    %case "Bits"
      %return Spec[Port][1]
    %case "PDOFullScale"
      %return CAST("Real",Spec[Port][2])
    %case "Gain"
      %return Spec[Port][3]
    %case "Offset"
      %return Spec[Port][4]
    %case "Filter"
      %return Spec[Port][5]

    %case "Raw"
      %return Spec[Port][2] == 0U
    %default
      %error Unknown request %<Entry> for GetIOPortSpec()
  %endswitch

%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeSigned( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
      %return 0

    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %return 1

    %default
      %error Unknown PDODataType: %<dtype>
  %endswitch
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeName( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_UINT8
      %return "si_uint8_T"
    %case tSS_INT8
      %return "si_sint8_T"
    %case tSS_UINT16
      %return "si_uint16_T"
    %case tSS_INT16
      %return "si_sint16_T"
    %case tSS_UINT32
      %return "si_uint32_T"
    %case tSS_INT32
      %return "si_sint32_T"
    %default
      %error Unknown PDODataType: %<dtype>; Known types: %<tSS_UINT8> %<tSS_INT8> %<tSS_UINT16> %<tSS_INT16> %<tSS_UINT32> %<tSS_INT32> %<tSS_BOOLEAN>
  %endswitch
%endfunction
