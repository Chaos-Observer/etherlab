%implements "ec_slave" "C"

%%
%% Hardware Driver for Beckhoff's EtherCAT Analog Input Terminal
%% series EL31xx
%% 
%% This TLC Implements the necessary IO Functions to communicate
%% with the EtherCAT Driver enabling the usage of a analog input
%% terminal.
%%
%% Copyright (C) 2006
%% Richard Hacker
%% IgH Essen GmbH
%% 
%% License: GPL

%include "EtherCAT.tlc"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockTypeSetup( block, system ) void
%% This function checks whether the EtherCAT system has been called once
%% before already, which is demonstrated by the existance of variable 
%% ::EtherCAT. If not, include C-header file for EtherCAT, 
%% and declare a variable where the slave's data structure is placed 
%% by EtherCAT when registering the slaves during mdlStart()
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %<InitEtherCAT()>
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function BlockInstanceSetup( block, system ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if EXISTS(InputPortSpec)
    %assign nm = SIZE(InputPortSpec)
    %if nm[1] > 0 && nm[1] != 4
      %error Unexpected column count for InputPortSpec %<InputPortSpec>
    %endif
    %addtorecord block NumInputs nm[0]
  %else
    %addtorecord block NumInputs 0
  %endif

  %if EXISTS(OutputPortSpec)
    %assign nm = SIZE(OutputPortSpec)
    %if nm[1] > 0 && nm[1] != 6
      %error Unexpected column count for OutputPortSpec %<OutputPortSpec>
    %endif
    %addtorecord block NumOutputs nm[0]
  %else
    %addtorecord block NumOutputs 0
  %endif

  %addtorecord block EtherCATTid InitEtherCATTask(block,system)
  %addtorecord block EtherCATSlaveId CompiledModel.EtherCAT.SlaveCount
  %assign CompiledModel.EtherCAT.SlaveCount = \
        CompiledModel.EtherCAT.SlaveCount + 1

  %foreach port = NumInputs
    %addtorecord block ECatInput { ...
          MapIdx 0 ...
          BitIdx 0 ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(InputPortSpec, "PDODataTypeId", port)) ...
          }
  %endforeach

  %assign FilterType = LibBlockSampleTime(block) == 0.0 ? 1 : 2

  %% Introduce the record FilterType to the block which defines what
  %% type of filter the block is working with. It is still unknown
  %% whether the block really uses a filter -- done later
  %% FilterType has 3 states:
  %%  0: Block does not use a filter
  %%  1: Block uses continuous filter
  %%  2: Block uses discrete filter
  %addtorecord block FilterType 0

  %assign FilterIdx = 0
  %foreach port = NumOutputs
    %addtorecord block ECatOutput { ...
          MapIdx 0 ...
          BitIdx 0 ...
          FilterIdx 0 ...
          FilterSpec GetIOPortSpec(OutputPortSpec, "Filter", port) ...
          RTWDType LibGetDataTypeNameFromId( ...
              GetIOPortSpec(OutputPortSpec, "PDODataTypeId", port)) ...
          }
    %if ECatOutput[port].FilterSpec
      %% The output is filtered, so set the block's FilterType
      %assign block.FilterType = FilterType
      %assign block.ECatOutput[port].FilterIdx = FilterIdx
      %assign FilterIdx = FilterIdx + LibBlockOutputSignalWidth(port)
    %endif
  %endforeach

  %if EXISTS(SdoConfig)
    %addtorecord block SdoVar "sdo_config_%<EtherCATSlaveId>"
    %addtorecord block SdoConfigCount SIZE(SdoConfig)[0]

    %openfile buf

    /* SDO Configuration for Block: %<Name> */
    struct sdo_config %<SdoVar>[] = {
      %foreach i = SdoConfigCount
        { \
        %<GetDTypeName(SdoConfig[i][2])>, \
        %<SdoConfig[i][0]>, %<SdoConfig[i][1]>, %<SdoConfig[i][3]> \
        },
      %endforeach
    };
    %closefile buf
    %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
  %else
    %addtorecord block SdoVar "NULL"
    %addtorecord block SdoConfigCount 0
  %endif

  %% Setup the pdo_mapping structure. Every single block input and output, 
  %% be it a scalar or vector, has an entry in this array structure.
  %addtorecord block PdoVar "pdo_%<EtherCATSlaveId>"
  %addtorecord block PdoCount 0
  %openfile buf

    /* PDO Mapping for Block: %<Name> */
    struct pdo %<PdoVar>[] = {
    %%
    %assign MapIdx = 0
    %assign IWorkIdx = 0
    %foreach port = NumInputs
      /* Mapping for Input Port %<port+1> */
      %assign PDODataTypeId = ...
                GetIOPortSpec(InputPortSpec, "PDODataTypeId", port)
      %assign Raw      = GetIOPortSpec(InputPortSpec, "Raw",      port)
      %assign MapCount = GetIOPortSpec(InputPortSpec, "MapCount", port)
      %assign DstDType = GetDTypeName(PDODataTypeId)
      %assign ECatInput[port].MapIdx = MapIdx
      %assign ECatInput[port].BitIdx = IWorkIdx
      %assign block.PdoCount = PdoCount + MapCount
      %foreach i = MapCount
        %if Raw & 2
          %assign BitOffsetAddr = ...
                "&%<LibBlockIWork(BitOffset,"","",IWorkIdx)>"
          %assign IWorkIdx = IWorkIdx + 1
        %else
          %assign BitOffsetAddr = "NULL"
        %endif
        %% PdoInfoIndex, PdoEntryInfoIdx, PdoDataType
        { %<InputMap[i][0]>, \
          %<InputMap[i][1]>, \
          %<DstDType>, \
          %%
          %% Source address for the data. If floating point is used
          %% the source is the internal integer work vector, otherwise
          %% it is the signal memory location
          &%<LibBlockPWork(DataPtr,"","",MapIdx)>, \
          %<BitOffsetAddr> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    %%
    %assign InputMapMax = MapIdx
    %addtorecord block InputMapMax InputMapMax
    %foreach port = NumOutputs
      /* Mapping for Output Port %<port+1> */
      %assign PDODataTypeId = ...
                GetIOPortSpec(OutputPortSpec, "PDODataTypeId", port)
      %assign Raw      = GetIOPortSpec(OutputPortSpec, "Raw",      port)
      %assign MapCount = GetIOPortSpec(OutputPortSpec, "MapCount", port)
      %assign SrcDType = GetDTypeName(PDODataTypeId)
      %assign ECatOutput[port].MapIdx = MapIdx - InputMapMax
      %assign ECatOutput[port].BitIdx = IWorkIdx
      %assign block.PdoCount = PdoCount + MapCount
      %foreach i = MapCount
        %if Raw & 2
          %assign BitOffsetAddr = ...
                "&%<LibBlockIWork(BitOffset,"","",IWorkIdx)>"
          %assign IWorkIdx = IWorkIdx + 1
        %else
          %assign BitOffsetAddr = "NULL"
        %endif
        %% PdoInfoIndex, PdoEntryIdx, PdoDataType
        { %<OutputMap[i][0]>, \
          %<OutputMap[i][1]>, \
          %<SrcDType>, \
          %%
          %% Source address for the data. If floating point is used
          %% the source is the internal integer work vector, otherwise
          %% it is the signal memory location
          &%<LibBlockPWork(DataPtr,"","",MapIdx)>, \
          %<BitOffsetAddr> \
        },
        %assign MapIdx = MapIdx + 1
      %endforeach
    %endforeach
    };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
          "Definitions", buf)>
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Start(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %% Cache the C variable name that is assigned to this block defining
  %% the PDO Map

  /* %<Type> Block: %<Name> 
   * Registering EtherCAT block %<ProductName> with Driver
   */
  if ((%<ETL.ErrStr> = ecs_reg_slave( \
           %<EtherCATTid>, /* TID */
           /* MasterId, DomainId, SlaveAlias, SlavePosition */
           %<MasterId>, %<DomainId>, %<SlaveAlias>, %<SlavePosition>,
           /* VendorId, ProductCode */
           %<VendorId>, %<ProductCode>,
           /* SdoConfigCount, SdoVar */
           %<SdoConfigCount>, %<SdoVar>,
           /* PDO_Info, PDO_Count, PDO_variable */
           %<GetPDOMapId(block)>, %<PdoCount>, %<PdoVar>))) {
        snprintf(%<ETL.ErrMsg>, sizeof(%<ETL.ErrMsg>), 
           "EtherCAT slave %<LibGetFormattedBlockPath(block)> register "
           "failed: %s", %<ETL.ErrStr>);
        %<LibSetRTModelErrorStatus( "%<ETL.ErrMsg>")>;
        return;
  }
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Outputs( block, system ) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if !NumOutputs
    %return
  %endif
  %%

  /* %<Type> Block: %<Name> */
  %%
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %% If the port is filtered, the output is the value of the filter's
      %% state variable
      %%
      %if PortWidth == 1
        %assign rollRegions = [0:0]
      %else
        %assign rollRegions = RollRegions == [] ...
                ? [0:%<PortWidth-1>] : RollRegions
      %endif
      %assign RollVars = ["y%<port>"]
      %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
        %%
        %assign FilterIdx = sigIdx + ECatOutput[port].FilterIdx
        %assign FilterLcv = ...
              (lcv != "" && FilterIdx) ? "%<lcv> + %<FilterIdx>" : lcv
        %%
        %if FilterType == 1
          %assign u0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
        %else
          %assign u0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
        %endif
        %%
        %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
      %endroll
    %else
      %%
      %assign Raw   = GetIOPortSpec(OutputPortSpec, "Raw",   port)
      %assign PDODataTypeId = ...
                GetIOPortSpec(OutputPortSpec, "PDODataTypeId",  port)
      %%
      %if Raw & 2
        /* Raw output port %<port+1> */
        %if PortWidth == 1
          %assign rollRegions = [0:0]
        %else
          %assign rollRegions = RollRegions == [] ...
                  ? [0:%<PortWidth-1>] : RollRegions
        %endif
        %assign RollVars = ["y%<port>", "<pwork>/DataPtr", ...
              "<iwork>/BitOffset"]
        %assign Mask = GetMask(OutputMap[ECatOutput[port].MapIdx])
        %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
              "Roller", RollVars
          %%
          %assign PWorkIdx = sigIdx + ECatOutput[port].MapIdx + InputMapMax
          %assign PWorkLcv = ...
                (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
          %%
          %assign shiftIdx = sigIdx + ECatOutput[port].BitIdx
          %assign shiftLcv = ...
                (lcv != "" && shiftIdx) ? "%<lcv>+%<shiftIdx>" : lcv
          %%
          %assign src = GetSrc(port,Raw,0,PWorkLcv,PWorkIdx,"",0) 
          %assign shift = LibBlockIWork(BitOffset,"",shiftLcv,shiftIdx)
          %%
          %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = \
              %<src> >> %<shift> & %<Mask>;
        %endroll
      %else
        %assign MapCount = GetIOPortSpec(OutputPortSpec, "MapCount", port)
        %%
        /* Unfiltered output port %<port+1> */
        %%
        %if PortWidth == 1
          %assign rollRegions = [0:0]
        %else
          %assign rollRegions = RollRegions == [] ...
                  ? [0:%<PortWidth-1>] : RollRegions
        %endif
        %if Raw
          %assign RollVars = ["y%<port>", "<pwork>/DataPtr"]
        %else
          %assign RollVars = ["y%<port>", "<pwork>/DataPtr", ...
                "<param>/%<OutputGainName[port]>", ...
                "<param>/%<OutputOffsetName[port]>"]
        %endif
        %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
                  "Roller", RollVars
          %%
          %assign PWorkIdx = sigIdx + ECatOutput[port].MapIdx + InputMapMax
          %assign PWorkLcv = ...
              (lcv != "" && PWorkIdx) ? "%<lcv> + %<PWorkIdx>" : lcv
          %%
          %assign u0 = GetSrc(port, Raw, MapCount != PortWidth, ...
                PWorkLcv, PWorkIdx, lcv, sigIdx)
          %<LibBlockOutputSignal(port,"",lcv,sigIdx)> = %<u0>;
        %endroll
      %endif
    %endif
  %endforeach
%endfunction


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Update(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
  %if FilterType == 2 || NumInputs
    /* %<Type> Block: %<Name> */
  %endif
  %%
  %%
  %if FilterType == 2
    /* Discrete low pass filter */
    %<WriteFilter(block)>
  %endif
  %%
  %foreach port = NumInputs
    %if !LibBlockInputSignalConnected(port)
      %continue
    %endif
    /* Input port %<port+1> */
    %%
    %assign Raw  = GetIOPortSpec(InputPortSpec, "Raw",   port)
    %assign PDODataTypeId = ...
                GetIOPortSpec(InputPortSpec, "PDODataTypeId",  port)
    %assign PortWidth = LibBlockInputSignalWidth(port)
    %%
    %if Raw
      %%
      %if PortWidth == 1
        %assign rollRegions = [0:0]
      %else
        %assign rollRegions = RollRegions == [] ...
                ? [0:%<PortWidth-1>] : RollRegions
      %endif
      %assign RollVars = (Raw & 2) ...
                ? ["u%<port>", "<iwork>/BitOffset", "<pwork>/DataPtr"] ...
                : ["u%<port>", "<pwork>/DataPtr"]
      %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
              "Roller", RollVars
        %%
        %assign PWorkIdx = sigIdx + ECatInput[port].MapIdx
        %assign PWorkLcv = ...
                (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
        %%
        %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
        %assign dst = GetDst(port,0,PWorkLcv,PWorkIdx,sigIdx)
        %%
        %if Raw & 2
          %assign ShiftIdx = sigIdx + ECatInput[port].BitIdx
          %assign ShiftLcv = ...
                  (lcv != "" && ShiftIdx) ? "%<lcv>+%<ShiftIdx>" : lcv
          %%
          %assign Shift = LibBlockIWork(BitOffset,"",ShiftLcv,ShiftIdx)
          %assign Mask = GetMask(InputMap[ECatInput[port].MapIdx])
          %%
          %<dst> = (%<dst> & ~(%<Mask><<%<Shift>)) 
                  | (%<src> & %<Mask>)<<%<Shift>; 
        %else
          %<dst> = %<src>;
        %endif
      %endroll
      %%
    %else
      %assign MaxValue = InputPDOFullScale[port] - 1.0
      %assign MinValue = ...
                GetIOPortSpec(InputPortSpec, "PDODataTypeSigned", port) ...
                ? -InputPDOFullScale[port] : 0.0
      { real_T value;

        %assign MapCount = GetIOPortSpec(InputPortSpec, "MapCount", port)
        %if PortWidth == 1
          %assign rollRegions = [0:0]
        %else
          %assign rollRegions = RollRegions == [] ...
                  ? [0:%<PortWidth-1>] : RollRegions
        %endif
        %assign RollVars = ["u%<port>", "<pwork>/DataPtr", ...
                "<param>/%<InputGainName[port]>"]
        %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
          %assign src = LibBlockInputSignal(port,"",lcv,sigIdx)
          %assign PWorkIdx = sigIdx + ECatInput[port].MapIdx
          %assign PWorkLcv = ...
                  (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
          %if InputGainName[port] == ""
            value = %<src> * %<InputPDOFullScale[port]>;
          %else
            %assign scale = ...
                LibBlockParameter(%<InputGainName[port]>,"",lcv,sigIdx)
            value = %<src> * %<InputPDOFullScale[port]> / %<scale>;
          %endif
          %assign dst = GetDst(port, PortWidth == MapCount, ...
                PWorkLcv, PWorkIdx, sigIdx)
          if (value > %<MaxValue>) {
            %<dst> = %<MaxValue>;
          } else if (value < %<MinValue>) {
            %<dst> = %<MinValue>;
          } else {
            %<dst> = value;
          }
        %endroll
      }
    %endif
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function Derivatives(block, system) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %if FilterType == 1
    /* %<Type> Block: %<Name> 
     * Continuous low pass filter
     */
    %<WriteFilter(block)>
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function WriteFilter(block) Output
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%
  %foreach port = NumOutputs
    %%
    %assign PortWidth = LibBlockOutputSignalWidth(port)
    %%
    %if ECatOutput[port].FilterSpec
      /* Filtered output port %<port+1> */
      %%
      %if PortWidth == 1
        %assign rollRegions = [0:0]
      %else
        %assign rollRegions = RollRegions == [] ...
                ? [0:%<PortWidth-1>] : RollRegions
      %endif
      %assign RollVars = ["<param>/%<OutputGainName[port]>", ...
                "<param>/%<OutputOffsetName[port]>", ...
                "<param>/%<OutputFilterName[port]>", "<pwork>/DataPtr"]
      %%
      %roll sigIdx = rollRegions, lcv = RollThreshold, block, ...
                "Roller", RollVars
        %%
        %assign PWorkIdx = sigIdx + ECatOutput[port].MapIdx + InputMapMax
        %assign FilterIdx = sigIdx + ECatOutput[port].FilterIdx
        %assign PWorkLcv = ...  
                (lcv != "" && PWorkIdx) ? "%<lcv>+%<PWorkIdx>" : lcv
        %assign FilterLcv = ...
                (lcv != "" && FilterIdx) ? "%<lcv>+%<FilterIdx>" : lcv
        %%
        %assign u0 = GetSrc(port,0,PWorkLcv,PWorkIdx,lcv,sigIdx)
        %assign k  = ...
                LibBlockParameter(%<OutputFilterName[port]>,"",lcv,sigIdx)
        %if FilterType == 1
          %assign y0 = LibBlockContinuousState("",FilterLcv,FilterIdx)
          %assign d0 = ...
                LibBlockContinuousStateDerivative("",FilterLcv,FilterIdx)
          %%
          %% The following is equivalent to:
          %%   <d0> = %<k>*(%<u0>) + (1 - %<k>)*%<d0>;
          %<d0>  = %<k> * (%<u0> - %<y0>);
        %else
          %assign d0 = LibBlockDiscreteState("",FilterLcv,FilterIdx)
          %<d0> += %<k> * (%<u0> - %<d0>);
        %endif
      %endroll
    %endif
  %endforeach
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDst(port, VectorInput, PWorkLcv, PWorkIdx, sigIdx)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %if VectorInput
    %assign dst = SPRINTF("((%s*)%s)", ...
        ECatInput[port].RTWDType, ...
        LibBlockPWork(DataPtr, "", PWorkLcv, PWorkIdx))
    %assign dst = "%<dst>[%<sigIdx>]"
    %return dst
  %else
    %return SPRINTF("*(%s*)(%s)", ...
        ECatInput[port].RTWDType, ...
        LibBlockPWork(DataPtr, "", PWorkLcv, PWorkIdx))
        )
  %endif
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetSrc(port, Raw, VectorInput, PWorkLcv, PWorkIdx, lcv, sigIdx) 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %if VectorInput
    %assign src = SPRINTF("((%s*)%s)", ...
         ECatOutput[port].RTWDType, ...
         LibBlockPWork(DataPtr,"",PWorkLcv,PWorkIdx))
    %assign src = "%<src>[%<sigIdx>]"
  %else
    %assign src = SPRINTF("*(%s*)(%s)", ...
         ECatOutput[port].RTWDType, ...
         LibBlockPWork(DataPtr,"",PWorkLcv,PWorkIdx))
  %endif

  %if Raw
    %return src
  %endif

  %assign GainType   = GetIOPortSpec(OutputPortSpec, "Gain",   port)
  %assign OffsetType = GetIOPortSpec(OutputPortSpec, "Offset", port)
  %assign src = SPRINTF("*(%s*)(%s)/%.1f", ...
       ECatOutput[port].RTWDType, ...
       LibBlockPWork(DataPtr,"",PWorkLcv,PWorkIdx), ...
       OutputPDOFullScale[port])

  %assign u0 = src
  %if GainType
    %assign gain = ...
        LibBlockParameter(%<OutputGainName[port]>,"",lcv,sigIdx)
    %assign u0 = "%<gain>*%<u0>"
  %endif
  %if OffsetType
    %assign offset = ...
        LibBlockParameter(%<OutputOffsetName[port]>,"",lcv,sigIdx)
    %assign u0 = "%<u0> + %<offset>"
  %endif

  %return u0
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetMask(PortMap)
  %assign PdoInfoIdx = PortMap[0]
  %assign PdoEntryInfoIdx = PdoInfo[PdoInfoIdx][2] + PortMap[1]
  %assign bitlen = PdoEntryInfo[PdoEntryInfoIdx][2]
  %return SPRINTF("0x%x", (1U << bitlen) - 1)
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetPDOMapId(block)
%% 
%% This function is used to define variables that are required to specify
%% the pdo mapping of an EtherCAT slave. The string that is returned
%% is the variable name that should be used when calling 
%% ecrt_slave_config_pdos()
%% This function depends on the following global Parameters:
%%   ProductName     string  Common name of the slave
%%   VendorId        int     Vendor Identification number
%%   ProductCode     int     Product Code of the slave
%%   ConfigLayout    int     Layout of slave memory - SDO, PDO, etc
%%   PdoInfo        This is a vector of integers organised in groups of 4:
%%                   entry0:    1 = Input; 0 = Output
%%                   entry1:    Index of PDO to map
%%                   entry2:    Group index of PdoEntryInfo
%%                   entry3:    Number of PdoEntryInfo groups
%%   PdoEntryInfo  This is a vector of integers organised in groups of 3:
%%                   entry0:    Index of the PDO
%%                   entry1:    Subindex of the PDO
%%                   entry2:    PDO bit length
%%
%% A typical value for PdoEntryInfo is:
%%      [[ 0x3101, 1,  8 ],   <- Group 0
%%       [ 0x3101, 2, 16 ],   <- Group 1
%%       [ 0x3102, 1,  8 ],   <- Group 2
%%       [ 0x3102, 2, 16 ]]   <- Group 3
%% describing the PDO entry information for the el31xx series. Here
%% are 4 groups of 3 values.
%%
%% A typical value for PdoInfo is:
%%     [[ 1,       <- Input
%%        0x1A00,  <- Pdo Index to map
%%        0,       <- starting with group[0] of PdoEntryInfo
%%        2     ], <- going on for 2 groups (i.e. group[0] and group[1])
%%
%%      [ 1, 0x1A01 2, 2 ]] <- Second group entry of PdoInfo, mapping 0x1A01
%%                             to group[2] and group[3] of PdoEntryInfo
%%                             (indices [6..11])
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %assign suffix = ...
        SPRINTF("%x_0x%08x_%u", VendorId, ProductCode, ConfigLayout)
  %assign varName = "pdo_info_%<suffix>"
  %if ISFIELD(CompiledModel.EtherCAT.PDOMap,varName)
    %return varName
  %endif
  %addtorecord CompiledModel.EtherCAT.PDOMap %<varName> 1

  %assign PdoEntryInfoId = "pdo_entry_info_%<suffix>"
  %openfile buf
  %<SPRINTF("/* PDO Entry Information for %s with config layout %u */", ...
        ProductName, ConfigLayout)>
  ec_pdo_entry_info_t %<PdoEntryInfoId>[] = {
  %foreach i = SIZE(PdoEntryInfo)[0]
    %<SPRINTF("{ 0x%04X, %u, %u }, /* %u */", PdoEntryInfo[i][0], ...
        PdoEntryInfo[i][1], PdoEntryInfo[i][2], i)>
  %endforeach
  };
  ec_pdo_info_t %<varName>[] = {
  %foreach i = SIZE(PdoInfo)[0]
    { \
    %% The value 0 or 1 indicates a simulink block output or input
    %% respectively. This in turn maps to EC_DIR_INPUT and EC_DIR_OUTPUT
    %% as far as the EtherCAT master is concerned.
    %% i.e. 0 -> block output -> EC_DIR_INPUT  -> Slave TxPDO
    %%      1 -> block input  -> EC_DIR_OUTPUT -> Slave RxPDO
    %%                                                       
    %%              Simulink Block                         
    %%              +-------------------------------+
    %%              |         EtherCAT Master       |       
    %%              |                               |       
    %%              |          +---------+          |       
    %% PdoInfo[][0] |   EC_DIR |Slave    | EC_DIR   | PdoInfo[][0]
    %%          = 1 |   OUTPUT |         | INPUT    | = 0      
    %%         ----->----------> Rx   Tx >---------->-----  
    %%              |          |   PDO   |          |      
    %%              |          |         |          |      
    %%              |          +---------+          |      
    %%              | output domain                 |      
    %%              |                  input domain |      
    %%              +-------------------------------+      
    %%
    %if PdoInfo[i][0] == 0
      %% simulink block output
      EC_DIR_INPUT, \
    %else
      %% simulink block input
      EC_DIR_OUTPUT, \
    %endif
    %<SPRINTF("0x%04X, %u", PdoInfo[i][1], PdoInfo[i][3])>, \
    &%<PdoEntryInfoId>[%<PdoInfo[i][2]>] },
    %if SIZE(PdoEntryInfo)[0] < PdoInfo[i][2] + PdoInfo[i][3]
       %error ############# Error creating PDO map for %<ProductName> ...
             for block %<LibGetFormattedBlockPath(block)>: ...
             struct ec_pdo_entry_info_t only has %<SIZE(PdoEntryInfo)[0]> ...
             elements, whereas you requested to map element ...
             %<PdoInfo[i][2] + PdoInfo[i][3]>. This will cause a segv!
              #############
    %endif
  %endforeach
  { EC_END, },
  };
  %closefile buf
  %<LibSetSourceFileSection(CompiledModel.EtherCAT.model_c, \
        "Definitions", buf)>

  %return varName
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetIOPortSpec( Spec, Entry, Port ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  %switch Entry
    %case "PDODataTypeId"
      %return Spec[Port][0] == tSS_BOOLEAN ? tSS_UINT8 : Spec[Port][0]
    %case "PDODataTypeName"
      %return GetDTypeName(Spec[Port][0])
    %case "PDODataTypeSigned"
      %return GetDTypeSigned(Spec[Port][0])
    %case "Raw"
      %return Spec[Port][1]
    %case "MapCount"
      %return Spec[Port][2]
    %case "Gain"
      %return Spec[Port][3]
    %case "Offset"
      %return Spec[Port][4]
    %case "Filter"
      %return Spec[Port][5]
    %default
      %error Unknown request %<Entry> for GetIOPortSpec()
  %endswitch

%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeSigned( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_BOOLEAN
    %case tSS_UINT8
    %case tSS_UINT16
    %case tSS_UINT32
      %return 0

    %case tSS_INT8
    %case tSS_INT16
    %case tSS_INT32
      %return 1

    %default
      %error Unknown PDODataType: %<dtype>
  %endswitch
%endfunction

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%function GetDTypeName( dtype ) void
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %switch dtype
    %case tSS_BOOLEAN
      %return "si_boolean_T"
    %case tSS_UINT8
      %return "si_uint8_T"
    %case tSS_INT8
      %return "si_sint8_T"
    %case tSS_UINT16
      %return "si_uint16_T"
    %case tSS_INT16
      %return "si_sint16_T"
    %case tSS_UINT32
      %return "si_uint32_T"
    %case tSS_INT32
      %return "si_sint32_T"
    %default
      %error Unknown PDODataType: %<dtype>; Known types: ...
                %<tSS_UINT8> %<tSS_INT8> %<tSS_UINT16> %<tSS_INT16> ...
                %<tSS_UINT32> %<tSS_INT32> %<tSS_BOOLEAN>
  %endswitch
%endfunction
