%% File : taskinfo.tlc
%% Created: Sat Jan 14 22:13:16 2006
%%
%% Description: 
%%   Real-Time Workshop wrapper functions interface generated for 
%%   S-function "taskinfo.c".
%%
%%         File generated by S-function Builder Block
%%
%%   For more information on using the Target Language with the 
%%   Real-Time Workshop, see the Target Language Compiler manual
%%   (under Real-Time Workshop) in the "Inlining S-Functions"
%%   chapter under the section and subsection:
%%     "Writing Block Target Files to Inline S-Functions",
%%        "Function-Based or Wrappered Code".
%%
%implements  taskinfo "C"
%% Function: BlockTypeSetup ===================================================
%%
%% Purpose:
%%      Set up external references for wrapper functions in the 
%%      generated code.
%%
%function BlockInstanceSetup(block, system) void

  %<LibAddToCommonIncludes("mdl_taskinfo.h")>

  %assign y1 = LibBlockOutputSignal(1, "", "", 0)
  %assign y2 = LibBlockOutputSignal(2, "", "", 0)
  %assign y3 = LibBlockOutputSignal(3, "", "", 0)

  %openfile buf
  /* %<Type> Block: %<Name> 
   * Functions that are directly called by mdl_wrapper.c to set various
   * task statistics
   */
  void mdlSetStats(real_T execTime, real_T timeStep, uint_T overrun)
  {
    %<y1> = execTime;
    %<y2> = timeStep;
    %<y3> = overrun;
  }

  void mdlSetWorldTime(real_T worldTime)
  {
    %<LibBlockRWork(WorldTime,"","",0)> = worldTime;
  }

  void mdlInitWorldTime(real_T worldTime)
  {
    %<LibBlockRWork(WorldTime,"","",0)> = worldTime;
    %<LibBlockRWork(oldWorldTime,"","",0)> = worldTime;
    %<LibBlockDiscreteState("","",3)> = worldTime;
  }
  %closefile buf
  %assign srcFile = LibGetModelDotCFile()
  %<LibSetSourceFileSection(srcFile, "Functions", buf)>

  %%
%endfunction

%% InitializeConditions =========================================================
 %%
 %function InitializeConditions(block, system) Output
  /* %<Type> Block: %<Name> */
  
  { 
    %<LibBlockRWork(WorldTime,"","",0)> = 0.0;
    %<LibBlockRWork(oldWorldTime,"","",0)> = 0.0;
    %<LibBlockRWork(k_p,"","",0)> = 0.0;
    %<LibBlockRWork(k_i,"","",0)> = 0.0;

    %<LibBlockIWork(0,"","",0)> = (int_T)1/%<Weight>;
   
    %<LibBlockDiscreteState("","",0)> = 0.0;
    %<LibBlockDiscreteState("","",1)> = 0.0;
    %<LibBlockDiscreteState("","",2)> = 1.0; /* Time traditionally has a slope of 1.0 :/ */
    %<LibBlockDiscreteState("","",3)> = 0.0;
  }
 %endfunction

%% Function: Outputs ==========================================================
%%
%% Purpose:
%%      Code generation rules for mdlOutputs function.
%%
%function Outputs(block, system) Output
  %assign wt  = LibBlockRWork(WorldTime,"","",0)
  %assign owt = LibBlockRWork(oldWorldTime,"","",0)
  %assign kp  = LibBlockRWork(k_p,"","",0)
  %assign ki  = LibBlockRWork(k_i,"","",0)
  %%
  %assign WorldTimeSteps = LibBlockDiscreteState("","",0)
  %assign TimeError      = LibBlockDiscreteState("","",1)
  %assign TimeRamp       = LibBlockDiscreteState("","",2)
  %assign InternalTime   = LibBlockDiscreteState("","",3)
  %%
  %assign start = LibBlockIWork(0,"","",0)
  %%
  %assign y0 = LibBlockOutputSignal(0, "", "", 0)
  %%

  /* START: %<Type> Block: %<Name>
   * Function to update internal task UTC time
   */
  %<y0> = %<InternalTime>;

  /* Check whether there is a new sample for world time */
  if (%<wt> !=  %<owt>) {
    real_T weight = %<Weight>, w;

    /* Calculate weight - the weighting of the input to a low pass filter
     * that wants to find out the average of the time steps. To make this 
     * filter faster, the initial samples (10 in this case) are weighted
     * as 1/n_samples, i.e. 1.0/1 for the first, 1.0/2 for the second, and
     * so on. That means that the filter has a very good estimate on the 
     * first sample already!
     * Note: %<start> counts down from 10 to 0
     */
    if ( %<start> ) {
      %<start>--;
      weight = 1.0/(%<CAST("Number",1/Weight)> - %<start>);
    }

    /* Here is the averaging function, using the weighting just calculated
     * Y(n+1) = (1-w)*Y(n) + w*U(n)
     */
    %<WorldTimeSteps> = (1.0 - weight)*%<WorldTimeSteps> 
                + weight*(%<wt> - %<owt>);
    %<owt> = %<wt>;

    /* Calculate the P and I factors of a PI controller that will follow 
     * the World Time, where the natural frequency of the second order
     * system is arbirarily chosen to be 1/2*pi*10 the frequency of world 
     * time steps. This makes for a reasonably slow filter that will not track
     * jitter in world time. In fact, this is an adaptive controller, changing
     * its parameters as input frequency changes.
     * Damping = 0.707, bearing minor overshoot
     */
    w = %<Omega>/%<WorldTimeSteps>;
    %<kp> = %<2*Damping>*w;
    %<ki> = w*w;

    /* Calculate the difference between world and internal time. This is Zero
     * Order Held - only gets updated when a new world time sample arrives
     */
    %<TimeError> = %<wt> - %<InternalTime>;
  }
  /* END %<Type> Block: %<Name> 
   */
%endfunction


%% Function: Update ==========================================================
%%
%% Purpose:
%%      Code generation rules for mdlUpdate function.
%%
%function Update(block, system) Output
  %assign kp  = LibBlockRWork(k_p,"","",0)
  %assign ki  = LibBlockRWork(k_i,"","",0)
  %%
  %assign TimeError = LibBlockDiscreteState("","",1)
  %assign TimeRamp = LibBlockDiscreteState("","",2)
  %assign InternalTime = LibBlockDiscreteState("","",3)
  %%
  %assign start = LibBlockIWork(0,"","",0)
  %%
  %assign y0 = LibBlockOutputSignal(0, "", "", 0)
  %%
  /* S-Function "taskinfo_wrapper" Block: %<Name> */

  %<InternalTime> += %<Ts>*(%<kp>*%<TimeError> + %<TimeRamp>);
  %<TimeRamp> += %<Ts>*%<ki>*%<TimeError>;
%endfunction
