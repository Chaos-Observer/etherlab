#!/usr/bin/env python

import zlib
import os.path
import sys

def dump_file(dest, z, line_prefix):
    for i in xrange(len(z)):
        # Insert new line every 16 characters
        if not i % 16: 
            if i:
                dest.write('"\n')
            dest.write('%s"' % line_prefix)

        # Insert character
        dest.write('\\x%02x' % ord(z[i]))
    dest.write('"')

# Need at least 3
if len(sys.argv) < 3:
    print """
Usage: %s <dest file> <model symbol file> <other files> ...

where: <dest file> is the name of the generated file
       <model symbol file> filename of the symbol file
       <other files> are 0 or more files that to be included (for later use)
""" % sys.argv[0]
    sys.exit(1)

# Reverse argument list. Then we can use pop()
sys.argv.reverse()

# Remove exec file name
sys.argv.pop()

g = open(sys.argv.pop(), 'w')

g.write("""\
/* Model symbol file
 *
 * The string below contains a compressed version of the shared object that
 * that describes the model with all its signals.
 * This string is unpacked and loaded by the buddy to be able to interpret
 * the data that is sent by the real time process 
 * 
 * Generated by: 
 * $Id$
 * 
 */

#include "msf.h"

""")

z = zlib.compress(open(sys.argv.pop()).read())
g.write('const size_t model_symbols_len = %i;\n' % len(z))
g.write('const char model_symbols[] = \n')
dump_file(g, z, "\t")
g.write(';\n\n')

g.write('const size_t other_files_count = %i;\n' % len(sys.argv))
g.write('const struct other_files other_files[] = {\n')
for f in sys.argv:
    z = zlib.compress(open(sys.argv.pop()).read())
    g.write('\t{ "%s", %i,\n' % (os.path.basename(f), len(z)))
    dump_file(g, z, "\t  ")
    g.write(' },\n')
g.write('\t{NULL,},\n')
g.write('};\n')
