#!/usr/bin/env python

import zlib
import sys

# Need 3 + 2*n arguments
if len(sys.argv) < 4 or (len(sys.argv) - 2) % 2:
    print """
usage: %s <model symbol file> \\
             <object1_name> <object1_file> <object2_name> <object2_file> ...

where: <model symbol file> is the name of the generated file
       <objectX_name> is the name of the object to be included
       <objectX_file> is the file name that will be compressed and included
""" % sys.argv[0]
    sys.exit(0)

# Reverse argument list. Then we can use pop()
sys.argv.reverse()

sys.argv.pop()
dest_file = sys.argv.pop()

files = {}
while len(sys.argv):
    name, f = sys.argv.pop(), sys.argv.pop()
    files[name] = f

g = open(dest_file, 'w')

g.write("""/* Model symbol file
 *
 * The string below contains a compressed version of the shared object that
 * that describes the model with all its signals.
 * This string is unpacked and loaded by the buddy to be able to interpret
 * the data that is sent by the real time process 
 * 
 * Generated by: 
 * $Id$
 * 
 */

#include "msf.h"
""")

g.write('\n')
g.write('const int model_symbols_cnt = %i;\n\n' % len(files))
g.write('const struct model_symbols model_symbols[] = {\n')

for n in files.keys():
    z = zlib.compress(open(files[n]).read())
    g.write('\t{ "%s", "%s", %i, \n' % (n, files[n], len(z)))

    g.write('\t  /* %s */\n' % files[n])
    for i in xrange(len(z)):
        if not i % 16: 
            if i:
                g.write('"\n')
            g.write('\t  "')
        g.write('\\x%02x' % ord(z[i]))
    g.write('" },\n')
g.write('\t  {NULL,},\n')
g.write('};\n')
